<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · PolynomialOptimization.jl</title><meta name="title" content="Reference · PolynomialOptimization.jl"/><meta property="og:title" content="Reference · PolynomialOptimization.jl"/><meta property="twitter:title" content="Reference · PolynomialOptimization.jl"/><meta name="description" content="Documentation for PolynomialOptimization.jl."/><meta property="og:description" content="Documentation for PolynomialOptimization.jl."/><meta property="twitter:description" content="Documentation for PolynomialOptimization.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">PolynomialOptimization.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="guide.html">Walkthrough</a></li><li class="is-active"><a class="tocitem" href="reference.html">Reference</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Optimization-reference"><span>Optimization reference</span></a></li><li><a class="tocitem" href="#Problem-definition"><span>Problem definition</span></a></li><li><a class="tocitem" href="#Relaxations"><span>Relaxations</span></a></li><li><a class="tocitem" href="#Optimization-and-problem-solutions"><span>Optimization and problem solutions</span></a></li><li><a class="tocitem" href="#Newton-polytope-construction-(manually)"><span>Newton polytope construction (manually)</span></a></li></ul></li><li><a class="tocitem" href="includedsolvers.html">Supported solvers</a></li><li><a class="tocitem" href="backend.html">Backend</a></li><li><a class="tocitem" href="auxreference.html">Reference of auxilliaries</a></li><li><a class="tocitem" href="intpolynomials.html">IntPolynomials</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="reference.html">Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="reference.html">Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/projekter/PolynomialOptimization.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/projekter/PolynomialOptimization.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h1 id="Optimization-reference"><a class="docs-heading-anchor" href="#Optimization-reference">Optimization reference</a><a id="Optimization-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-reference" title="Permalink"></a></h1><p>This reference page lists all functions that are relevant for polynomial optimization.</p><h2 id="Problem-definition"><a class="docs-heading-anchor" href="#Problem-definition">Problem definition</a><a id="Problem-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-definition" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Problem" href="#PolynomialOptimization.Problem"><code>PolynomialOptimization.Problem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Problem</code></pre><p>The basic structure that describes a polynomial optimization problem. In order to perform optimizations on this problem, construct <a href="reference.html#PolynomialOptimization.Relaxation.AbstractRelaxation"><code>AbstractRelaxation</code></a>s from it. Note that the variables in a <code>Problem</code> are rewritten to internal data types, i.e., they will probably not display in the same way as the original variables (they are simply numbered consecutively).</p><p>This type is not exported.</p><p>See also <a href="reference.html#PolynomialOptimization.poly_problem-Tuple{P} where P&lt;:AbstractPolynomialLike"><code>poly_problem</code></a>, <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a>, <a href="reference.html#PolynomialOptimization.Relaxation.AbstractRelaxation"><code>AbstractRelaxation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/Problem.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.poly_problem-Tuple{P} where P&lt;:AbstractPolynomialLike" href="#PolynomialOptimization.poly_problem-Tuple{P} where P&lt;:AbstractPolynomialLike"><code>PolynomialOptimization.poly_problem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poly_problem(objective; zero=[], nonneg=[], psd=[], perturbation=0.,
    factor_coercive=1, perturbation_coefficient=0., perturbation_form=0,
    noncompact=(0., 0), tighter=false, soscert=false, verbose=false,
    monomial_index_type=UInt)</code></pre><p>Analyze a polynomial optimization problem and return a <a href="reference.html#PolynomialOptimization.Problem"><code>Problem</code></a> that can be used for sparse analysis and optimization.</p><p><strong>Arguments</strong></p><p><strong>Problem formulation</strong></p><ul><li><code>objective::AbstractPolynomial</code>: the objective that is to be minimized</li><li><code>zero::AbstractVector{&lt;:AbstractPolynomialLike}</code>: a vector with all polynomials that should be constrained to be zero.</li><li><code>nonneg::AbstractVector{&lt;:AbstractPolynomialLike}</code>: a vector with all polynomials that should be constrained to be nonnegative. The values of the polynomials must always be effectively real-valued (in the sense that their imaginary parts evaluate to zero even if no values are plugged in).</li><li><code>psd::AbstractVector{&lt;:AbstractMatrix{&lt;:AbstractPolynomialLike}}</code>: a vector of matrices that should be constrainted to be positive semidefinite. The matrices must be symmetric/hermitian.</li></ul><p><strong>Problem representation</strong></p><ul><li><code>monomial_index_type::Type{&lt;:Integer}</code>: internally, whatever interface of <code>MultivariatePolynomials</code> is used, the data is converted to the efficient <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntPolynomial"><code>IntPolynomial</code></a> representation. Every monomial is represented by a single number of the type given for this keyword argument. The default is usually a good choice, allowing quite large problems. For very small problems, the index type might be reduced (however, note that the index must be large enough to capture the monomial for every desired relaxation, and there will be no warning on overflow!); if the problem is extremely large, it might also be enlarged to <code>UInt128</code> or <code>BigInt</code>, the latter in particular with potentially severe performance and memory consumption issues.</li></ul><p><strong>Problem modification</strong></p><p><strong>For unique solution extraction</strong></p><ul><li><code>perturbation::Union{Float64, &lt;:AbstractVector{Float64}}</code>: adds a random linear perturbation with an absolute value not greater than this value to the objective for every variable (or, in the vector case, with different magnitudes for each variable). This will ensure that the result is unique and hence solution extraction will always work, at the cost of potentially reducing sparsity and slightly changing the actual result.</li></ul><p><strong>For noncompact sets</strong></p><p>The following four parameters allow to automatically modify the problem according to a strategy by <a href="https://doi.org/10.1007/s10107-021-01634-1">Mai, Lasserre, and Magron</a> that was mainly developed for noncompact semialgebraic sets. It will modify the objective to</p><p class="math-container">\[\mathrm{factor\_coercive} \bigl(
    \mathrm{objective} + \mathrm{perturbation\_coefficient} \cdot \mathrm{perturbation\_form}
  \bigr)\text.\]</p><p>Usually, <code>perturbation_form</code> and <code>factor_coercive</code> are both given by <span>$1 + \lVert\mathrm{variables}\rVert^2$</span>. If <code>perturbation_coefficient</code> is strictly positive, then for almost all degrees, the optimal value of the modified problem is then in <span>$\bigl[f_{\mathrm{opt}}, f_{\mathrm{opt}} + \mathrm{perturbation\_coefficient} \cdot \mathrm{perturbation\_form}^{d_\mathrm o}(x_{\mathrm{opt}})\bigr]$</span>. Often, this even works for a strictly zero coefficient (relatively generic conditions were found by <a href="https://doi.org/10.1007/s10107-022-01878-5">Huang, Nie, and Yuan</a>). Note that when modifying a problem in such a way, all sparsity methods provided by this package will be useless.</p><ul><li><code>factor_coercive::AbstractPolynomial</code>: Let <span>$k$</span> be divisible by <span>$2r$</span>, then this must be the dehomogenization of a coercive positive form in <span>$n+1$</span> variables of degree <span>$2r$</span> to the power <span>$k/(2r)$</span>. Be aware that using this parameter will multiply the objective by another polynomial and therefore require a higher total relaxation degree to model the problem! Set this factor to zero (or use the parameter <code>soscert</code>) in order to change the polynomial optimization problem into one of certifying membership in the cone of SOS polynomials.</li><li><code>perturbation_coefficient::Float64</code>: a nonnegative prefactor that determines the strength of the perturbation and whose inverse dictates the scaling of a sufficient lower degree bound that guarantees optimality.</li><li><code>perturbation_form::AbstractPolynomial</code>: must be the dehomogenization of a positive form in <code>n+1</code> variables of degree <code>2(1+degree(objective)÷2)</code>.</li><li><code>noncompact::Tuple{Real,Int}</code>, now called <span>$(\epsilon, k)$</span>: this is a shorthand that will set the previous three parameters to their standard values, <code>factor_coercive=(1 + sum(variables.^2))^k</code>, <code>perturbation_coefficient</code> to the value passed to this parameter, and <code>perturbation_form=(1 + sum(variables.^2))^maxhalfdegree(objective)</code>. Be aware that using this parameter will multiply the objective by another polynomial and therefore require a higher total relaxation degree to model the problem!</li></ul><p><strong>For convergence at earlier levels</strong></p><p><a href="https://doi.org/10.1007/s10107-018-1276-2">Nie</a> provides a way to add additional constraints based on optimality conditions to the problems. This can speed up or make possible convergence at all. However, not every problem can be tightened in such a way, and sometimes, tightening might also increase the minimal degree required to optimize the problem. Note that the problem will end up with more equality and inequality constraints than originally entered. The augmentation does not change the solution of the original problem in case the minimum is attained at a critical point; if it is not, tightening will lead to missing this minimum.</p><ul><li><code>tighter::Union{Bool,Symbol}</code>: if set to a valid solver or <code>true</code> (= choose default), tries to automatically construct constraints using Nie&#39;s method. Note that the algorithm internally needs to create lots of dense polynomials of appropriate degrees before solving for the coefficients. It is therefore possible that for larger problems, this can take a very long time. For a list of supported solvers, see <a href="backend.html#solvers_tighten">the solver reference</a>. This parameter can also be called <code>tighten</code>; if any of those two is <code>true</code>, it is assumed that this was the intended value.</li></ul><p><strong>SOS membership</strong></p><p>Usually, a problem constructed with <code>poly_problem</code> will minimize the given objective under the constraints. Instead, membership of the objective in the quadratic module generated by the constraints can also be checked.</p><ul><li><code>soscert::Bool</code>: if set to true, disables the lower bound optimization. This is simply a shorthand for setting <code>factor_coercive</code> to zero.</li></ul><p><strong>Progress monitoring</strong></p><ul><li><code>verbose::Bool</code>: if set to true, information about the current state of the method is printed; this may be useful for large and complicated problems whose construction can take some time.</li></ul><p>See also <a href="reference.html#PolynomialOptimization.Problem"><code>Problem</code></a>, <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a>, <a href="reference.html#PolynomialOptimization.Relaxation.AbstractRelaxation"><code>Relaxation.AbstractRelaxation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/Problem.jl#L128-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.variables" href="#MultivariatePolynomials.variables"><code>MultivariatePolynomials.variables</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">variables(problem::Union{Problem,&lt;:AbstractRelaxation})</code></pre><p>Returns the original variables (not their internal rewrites) associated to a given polynomial optimization problem. This defines the order in which solutions are returned. In the complex case, they do not contain conjugates.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a>, <a href="reference.html#PolynomialOptimization.poly_solutions"><code>poly_solutions</code></a>, <a href="reference.html#PolynomialOptimization.poly_all_solutions"><code>poly_all_solutions</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/Problem.jl#L25-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.nvariables" href="#MultivariatePolynomials.nvariables"><code>MultivariatePolynomials.nvariables</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nvariables(problem::Union{Problem,&lt;:AbstractRelaxation})</code></pre><p>Returns the number of variables associated to a given polynomial optimization problem. In the complex case, conjugates are not counted.</p><p>See also <a href="reference.html#MultivariatePolynomials.variables"><code>variables</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/Problem.jl#L34-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isreal" href="#Base.isreal"><code>Base.isreal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isreal(problem::Union{Problem,&lt;:AbstractRelaxation})</code></pre><p>Returns whether a given polynomial optimization problem contains only real-valued variables or also complex ones.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/Problem.jl#L47-L51">source</a></section></article><h2 id="Relaxations"><a class="docs-heading-anchor" href="#Relaxations">Relaxations</a><a id="Relaxations-1"></a><a class="docs-heading-anchor-permalink" href="#Relaxations" title="Permalink"></a></h2><p>Types and functions related to relaxations of polynomial optimization problems are found in the submodule <code>Relaxation</code>. The types in this module are mostly not exported, so that a qualified name is required.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Relaxation.AbstractRelaxation" href="#PolynomialOptimization.Relaxation.AbstractRelaxation"><code>PolynomialOptimization.Relaxation.AbstractRelaxation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractRelaxation</code></pre><p>This is the general abstract type for any kind of relaxation of a polynomial optimization problem. Its concrete types can be used for analyzing and optimizing the problem.</p><p>See also <a href="reference.html#PolynomialOptimization.poly_problem-Tuple{P} where P&lt;:AbstractPolynomialLike"><code>poly_problem</code></a>, <a href="reference.html#PolynomialOptimization.Problem"><code>Problem</code></a>, <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/Relaxation.jl#L11-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.poly_problem-Tuple{PolynomialOptimization.Relaxation.AbstractRelaxation}" href="#PolynomialOptimization.poly_problem-Tuple{PolynomialOptimization.Relaxation.AbstractRelaxation}"><code>PolynomialOptimization.poly_problem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poly_problem(relaxation::AbstractRelaxation)</code></pre><p>Returns the original problem associated with a relaxation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/Relaxation.jl#L191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Relaxation.basis" href="#PolynomialOptimization.Relaxation.basis"><code>PolynomialOptimization.Relaxation.basis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">basis(relaxation::AbstractRelaxation[, clique::Int]) -&gt; IntMonomialVector</code></pre><p>Constructs the basis that is associated with a given polynomial relaxation. If <code>clique</code> is given, only the monomials that are relevant for the given clique must be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/Relaxation.jl#L198-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.degree-Tuple{PolynomialOptimization.Relaxation.AbstractRelaxation}" href="#MultivariatePolynomials.degree-Tuple{PolynomialOptimization.Relaxation.AbstractRelaxation}"><code>MultivariatePolynomials.degree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">degree(problem::AbstractRelaxation)</code></pre><p>Returns the degree associated with the relaxation of a polynomial optimization problem.</p><p>See also <a href="reference.html#PolynomialOptimization.poly_problem-Tuple{P} where P&lt;:AbstractPolynomialLike"><code>poly_problem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/Relaxation.jl#L318-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Relaxation.groupings" href="#PolynomialOptimization.Relaxation.groupings"><code>PolynomialOptimization.Relaxation.groupings</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">groupings(relaxation::AbstractRelaxation) -&gt; RelaxationGroupings</code></pre><p>Analyze the current state and return the bases and cliques as indicated by its relaxation in a <a href="reference.html#PolynomialOptimization.Relaxation.RelaxationGroupings"><code>RelaxationGroupings</code></a> struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/Relaxation.jl#L206-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.iterate!-Tuple{PolynomialOptimization.Relaxation.AbstractRelaxation}" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.iterate!-Tuple{PolynomialOptimization.Relaxation.AbstractRelaxation}"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.iterate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iterate!(relaxation::AbstractRelaxation)</code></pre><p>Some sparse polynomial optimization relaxations allow to iterate their sparsity, which will lead to a more dense representation and might give better bounds at the expense of a more costly optimization. Return <code>nothing</code> if the iterations converged (<code>state</code> did not change any more), else return the new state. Note that <code>state</code> will be modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/Relaxation.jl#L215-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Type-Tuple{PolynomialOptimization.Problem, Tuple}" href="#Core.Type-Tuple{PolynomialOptimization.Problem, Tuple}"><code>Core.Type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Relaxation.XXX(problem::Problem[, degree]; kwargs...)</code></pre><p>This is a convenience wrapper for <code>Relaxation.XXX(Relaxation.Dense(problem, degree))</code> that works for any <a href="reference.html#PolynomialOptimization.Relaxation.AbstractRelaxation"><code>AbstractRelaxation</code></a> <code>XXX</code>. <code>degree</code> is the degree of the Lasserre relaxation, which must be larger or equal to the halfdegree of all polynomials that are involved. If <code>degree</code> is omitted, the minimum required degree will be used. Specifying a degree larger than the minimal only makes sense if there are inequality or PSD constraints present, else it needlessly complicates calculations without any benefit.</p><p>The keyword arguments will be passed on to the constructor of <code>XXX</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/Relaxation.jl#L224-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Relaxation.RelaxationGroupings" href="#PolynomialOptimization.Relaxation.RelaxationGroupings"><code>PolynomialOptimization.Relaxation.RelaxationGroupings</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RelaxationGroupings</code></pre><p>Contains information about how the elements in a certain (sparse) polynomial optimization problem combine. Groupings are contained in the fields <code>obj</code>, <code>zero</code>, <code>nonneg</code>, and <code>psd</code>:</p><ul><li><span>$\sum_i \mathit{obj}_i^\top \sigma_i \overline{\mathit{obj}_i}$</span> is the SOS representation of the objective with <span>$\sigma_i \succeq 0$</span></li><li><span>$\sum_i \mathit{zero}_{k, i}^\top f_k$</span> is the prefactor for the kᵗʰ equality constraint with <span>$f_k$</span> a free vector</li><li><span>$\sum_i \mathit{nonneg}_{k, i}^\top \sigma_{k, i} \overline{\mathit{nonneg}_{k, i}}$</span> is the SOS representation of the prefactor of the kᵗʰ nonnegative constraint with <span>$\sigma_{k, i} \succeq 0$</span></li><li><span>$\sum_i (\mathit{psd}_{k, i}^\top \otimes \mathbb1) Z_{k, i} (\overline{\mathit{psd}_{k, i}} \otimes \mathbb1)$</span> is the SOS matrix representation of the prefactor of the kᵗʰ PSD constraint with <span>$Z_{k, i} \succeq 0$</span></li></ul><p>The field <code>var_cliques</code> contains a list of sets of variables, each corresponding to a variable clique in the total problem. In the complex case, only the declared variables are returned, not their conjugates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/Relaxation.jl#L21-L36">source</a></section></article><h3 id="Relaxations-based-on-a-global-basis"><a class="docs-heading-anchor" href="#Relaxations-based-on-a-global-basis">Relaxations based on a global basis</a><a id="Relaxations-based-on-a-global-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Relaxations-based-on-a-global-basis" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Relaxation.AbstractRelaxationBasis" href="#PolynomialOptimization.Relaxation.AbstractRelaxationBasis"><code>PolynomialOptimization.Relaxation.AbstractRelaxationBasis</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractRelaxationBasis{Prob} &lt;: AbstractRelaxation{Prob}</code></pre><p>An <code>AbstractRelaxationBasis</code> is a relaxation of a polynomial optimization problem that is built using a single basis for everything (objective and constraints). The groupings for the individual elements will come from a degree truncation of the same shared basis for all constituents of the problem (intersected with a parent grouping).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/basis/Basis.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Relaxation.Dense" href="#PolynomialOptimization.Relaxation.Dense"><code>PolynomialOptimization.Relaxation.Dense</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Dense(problem::Problem[, degree])</code></pre><p>Constructs a full dense relaxation out of a polynomial optimization problem. This is the largest possible representation for a given degree bound, giving the best bounds. It is wasteful at the same time, as a Newton relaxation gives equally good bounds; but contrary to the Newton one, solution reconstruction works much better with a dense basis. <code>degree</code> is the degree of the Lasserre relaxation, which must be larger or equal to the halfdegree of all polynomials that are involved. If <code>degree</code> is omitted, the minimum required degree will be used. Specifying a degree larger than the minimal only makes sense if there are inequality or PSD constraints present, else it needlessly complicates calculations without any benefit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/basis/Dense.jl#L7-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Relaxation.Newton" href="#PolynomialOptimization.Relaxation.Newton"><code>PolynomialOptimization.Relaxation.Newton</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Newton(relaxation::AbstractRelaxation; [method,] parameters...)</code></pre><p>Constructs a relaxation based on the Newton halfpolytope applied to another relaxation of a polynomial optimization problem. This will be a superset of the largest possible representation for a given degree bound, with no negative consequences for finding the optimum. It can be much smaller than a dense basis, but solution reconstruction may be harder.</p><p>When constraints are present, the polytope is determined based on the Putinar reformulation, where all constraints and the objective are moved to one side (comprising a new virtual objective). The prefactors for the constraints are determined by the previous relaxation method.</p><p>Note that for the complex-valued hierarchy, strictly speaking there is no &quot;Newton polytope&quot;; as the representation of complex-valued polynomials is unique, the process is much simpler there; still, the size reduction is accomplished by using <code>Newton</code>.</p><p>The <code>method</code> determines which solver to use for determining the Newton polytope. If omitted, this will be the default solver (in the complex case, it must be <code>:complex</code>). The <code>parameters</code> are passed on to <a href="reference.html#PolynomialOptimization.Newton.halfpolytope"><code>Newton.halfpolytope</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/basis/Newton.jl#L7-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Relaxation.Custom" href="#PolynomialOptimization.Relaxation.Custom"><code>PolynomialOptimization.Relaxation.Custom</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Custom(problem::Problem, basis)</code></pre><p>Constructs a relaxation out of a polynomial optimization problem for the case in which a suitable basis is already known.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/basis/Custom.jl#L7-L11">source</a></section></article><h3 id="Relaxations-based-on-individual-sparsity"><a class="docs-heading-anchor" href="#Relaxations-based-on-individual-sparsity">Relaxations based on individual sparsity</a><a id="Relaxations-based-on-individual-sparsity-1"></a><a class="docs-heading-anchor-permalink" href="#Relaxations-based-on-individual-sparsity" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Relaxation.AbstractRelaxationSparse" href="#PolynomialOptimization.Relaxation.AbstractRelaxationSparse"><code>PolynomialOptimization.Relaxation.AbstractRelaxationSparse</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractRelaxationSparse{Prob} &lt;: AbstractRelaxation{Prob}</code></pre><p>An <code>AbstractRelaxationSparse</code> is a relaxation of a polynomial optimization problem that applies sparsity methods to reduce the size of the associated problem, possibly at the expense of lowering the objective bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/sparse/Sparse.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Relaxation.SparsityCorrelative" href="#PolynomialOptimization.Relaxation.SparsityCorrelative"><code>PolynomialOptimization.Relaxation.SparsityCorrelative</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SparsityCorrelative(relaxation::AbstractRelaxation; [high_order_zero,]
    [high_order_nonneg,] [high_order_psd,] [low_order_zero,] [low_order_nonneg,]
    [low_order_psd,] chordal_completion=true, verbose::Bool=false)</code></pre><p>Analyze the correlative sparsity of a problem. Correlative sparsity is a variable-based sparsity analysis. It was first defined by <a href="https://doi.org/10.1137/050623802">Waki et al.</a> in 2006 and extended by <a href="https://doi.org/10.1137/15M1034386">Josz and Molzahn</a> in 2018. Variables are grouped into cliques based on the terms in the objective in which they appear together. Additional grouping is induced by variables that occur anywhere in a constraint of high order; or by variables that occur in a term in a constraint of low order. The parameters <code>high_order_...</code> allow to specify which constraints - identified by their indices - are of high order. If the parameter is omitted, all such constraints are of high order. Conversely, <code>low_order_...</code> can be used to specify that all <em>but</em> the listed constraints are of high order. Both parameters cannot be used simultaneously for the same set of constraints. Note that the order of the constraints is also influenced by the parent relaxation. If a correlative sparsity relaxation is applied to another relaxation that already limited the prefactor of a constraint to be of degree zero, it must necessarily be of low order.</p><p>By default, the correlative sparsity graph is completed to a chordal graph before the cliques are determined, which guarantees that the maximal cliques can be determined quickly; however, this may degrade the sparsity and it may be favorable not to carry out the completion.</p><p>If correlative and term sparsity are to be used together, use <a href="reference.html#PolynomialOptimization.Relaxation.SparsityCorrelativeTerm"><code>SparsityCorrelativeTerm</code></a> instead of nesting the sparsity objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/sparse/Correlative.jl#L5-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Relaxation.SparsityTerm" href="#PolynomialOptimization.Relaxation.SparsityTerm"><code>PolynomialOptimization.Relaxation.SparsityTerm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SparsityTerm</code></pre><p>Common base class that term sparsity methods use or wrap. The <a href="reference.html#PolynomialOptimization.Relaxation.SparsityTermBlock"><code>SparsityTermBlock</code></a> and <a href="reference.html#PolynomialOptimization.Relaxation.SparsityTermChordal"><code>SparsityTermChordal</code></a> constructors are shorthands that create <code>SparsityTerm</code> objects with the <code>method</code> parameter appropriately set. <a href="reference.html#PolynomialOptimization.Relaxation.SparsityCorrelativeTerm"><code>SparsityCorrelativeTerm</code></a> is a very thin wrapper around <code>SparsityTerm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/sparse/Term.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Relaxation.SparsityTermBlock" href="#PolynomialOptimization.Relaxation.SparsityTermBlock"><code>PolynomialOptimization.Relaxation.SparsityTermBlock</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SparsityTermBlock(relaxation::AbstractProblem; verbose::Bool=false)</code></pre><p>Analyze the term sparsity of the problem. <a href="https://doi.org/10.1137/19M1307871">Term sparsity</a> is a recent iterative sparsity analysis that groups terms with shared supports. Its last iteration will give the same optimal value as the original problem, although it may still be of a smaller size. Often, even the uniterated analysis already gives the same bound as the dense problem. The terms are grouped based on connected components of a graph; this can be improved by using the smallest chordal extension (see <a href="reference.html#PolynomialOptimization.Relaxation.SparsityTermChordal"><code>SparsityTermChordal</code></a>), which will lead to even smaller problem sizes, but typically also worse bounds.</p><p>If correlative and term sparsity are to be used together, use <a href="reference.html#PolynomialOptimization.Relaxation.SparsityCorrelativeTerm"><code>SparsityCorrelativeTerm</code></a> or nest the sparsity objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/sparse/Term.jl#L391-L402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Relaxation.SparsityTermChordal" href="#PolynomialOptimization.Relaxation.SparsityTermChordal"><code>PolynomialOptimization.Relaxation.SparsityTermChordal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SparsityTermChordal(relaxation::AbstractProblem; chordal_completion=true, verbose=false)</code></pre><p>Analyze the term sparsity of the problem using chordal cliques. <a href="https://doi.org/10.1137/20M1323564">Chordal term sparsity</a> is a recent iterative sparsity analysis that groups terms with shared supports. Even in its last iteration, it may give strictly smaller values than the dense problem. The basis elements are grouped in terms of chordal cliques of the term sparsity graph. This uses maximal cliques; as obtaining maximal cliques of an arbitrary graph is not efficient, the graph is extended to a chordal graph if <code>chordal_completion</code> is <code>true</code> using a heuristic. Disabling the chordal completion can lead to smaller problem sizes.</p><p>If correlative and term sparsity are to be used together, use <a href="reference.html#PolynomialOptimization.Relaxation.SparsityCorrelativeTerm"><code>SparsityCorrelativeTerm</code></a> or nest the sparsity objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/sparse/Term.jl#L405-L416">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Relaxation.SparsityCorrelativeTerm" href="#PolynomialOptimization.Relaxation.SparsityCorrelativeTerm"><code>PolynomialOptimization.Relaxation.SparsityCorrelativeTerm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SparsityCorrelativeTerm(relaxation::AbstractRelaxation; method=TERM_MODE_BLOCK, kwargs...)</code></pre><p>Analyze both the <a href="http://arxiv.org/abs/2005.02828v2">correlative as well as the term sparsity</a> of the problem. This is the most versatile kind of sparsity analysis, combining the effects of correlative sparsity with term analysis per clique. However, it is nothing more than first performing correlative sparsity analysis, followed by term sparsity analysis. This constructor will take all keyword arguments and distribute them appropriately to the <a href="reference.html#PolynomialOptimization.Relaxation.SparsityCorrelative"><code>SparsityCorrelative</code></a> and <a href="reference.html#PolynomialOptimization.Relaxation.SparsityTerm"><code>SparsityTerm</code></a> constructors. The returned object will be a very thin wrapper around <a href="reference.html#PolynomialOptimization.Relaxation.SparsityTerm"><code>SparsityTerm</code></a>, with the only difference in printing; <a href="reference.html#PolynomialOptimization.Relaxation.SparsityCorrelativeTerm"><code>SparsityCorrelativeTerm</code></a> objects by default print the clique grouping. Note that the same can be achieved for any relaxation (or groupings of a relaxation) if the IO parameter <code>bycliques</code> is set to <code>true</code>.</p><p>See also <a href="reference.html#PolynomialOptimization.Relaxation.SparsityCorrelative"><code>SparsityCorrelative</code></a>, <a href="reference.html#PolynomialOptimization.Relaxation.SparsityTermBlock"><code>SparsityTermBlock</code></a>, <a href="reference.html#PolynomialOptimization.Relaxation.SparsityTermChordal"><code>SparsityTermChordal</code></a>, <a href="reference.html#PolynomialOptimization.Relaxation.TermMode"><code>TermMode</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/sparse/CorrelativeTerm.jl#L11-L24">source</a></section><section><div><pre><code class="language-julia hljs">SparsityCorrelativeTerm(relaxation::SparsityCorrelative; method=TERM_MODE_BLOCK, kwargs...)</code></pre><p>This form allows to wrap an already created correlative sparsity pattern into a term sparsity pattern.</p><p>See also <a href="reference.html#PolynomialOptimization.Relaxation.SparsityCorrelative"><code>SparsityCorrelative</code></a>, <a href="reference.html#PolynomialOptimization.Relaxation.TermMode"><code>TermMode</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/sparse/CorrelativeTerm.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Relaxation.TermMode" href="#PolynomialOptimization.Relaxation.TermMode"><code>PolynomialOptimization.Relaxation.TermMode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@enum TermMode TERM_MODE_DENSE TERM_MODE_BLOCK TERM_MODE_CLIQUES
    TERM_MODE_CHORDAL_CLIQUES TERM_MODE_NONE</code></pre><p>Specifies which kind of completion procedure is used for the iteration of term sparsity pattern. Valid values are <code>TERM_MODE_DENSE</code> (<a href="reference.html#PolynomialOptimization.Relaxation.Dense"><code>Dense</code></a>), <code>TERM_MODE_BLOCK</code> (<a href="reference.html#PolynomialOptimization.Relaxation.SparsityTermBlock"><code>SparsityTermBlock</code></a>), <code>TERM_MODE_CHORDAL_CLIQUES</code> (<a href="reference.html#PolynomialOptimization.Relaxation.SparsityTermChordal"><code>SparsityTermChordal</code></a>), and <code>TERM_MODE_CLIQUES</code> (<a href="reference.html#PolynomialOptimization.Relaxation.SparsityTermChordal"><code>SparsityTermChordal</code></a> with <code>chordal_completion = false</code>). <code>TERM_MODE_NONE</code> can be used during iteration to disable the iteration of individual constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/sparse/Term.jl#L9-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Relaxation.CliqueMerged" href="#PolynomialOptimization.Relaxation.CliqueMerged"><code>PolynomialOptimization.Relaxation.CliqueMerged</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CliqueMerged(relaxation::AbstractRelaxation)</code></pre><p>Performs clique merging on the parent <code>relaxation</code>. Clique merging may allow to reduce the solver time by merging together smaller blocks of variables with huge overlap into a single larger one; however, it comes at a significant cost itself. Basically, clique merging undoes some of the sparsity analysis performed before when it might be too excessive. This is is an equivalent reformulation that is as exact as <code>relaxation</code> itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/sparse/CliqueMerged.jl#L108-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.iterate!-Tuple{PolynomialOptimization.Relaxation.SparsityTerm}" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.iterate!-Tuple{PolynomialOptimization.Relaxation.SparsityTerm}"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.iterate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iterate!(relaxation::Union{SparsityTerm,SparsityCorrelativeTerm}; [method,]
    objective=true, zero=true, nonneg=true, psd=true, varclique_methods=missing)</code></pre><p><a href="reference.html#PolynomialOptimization.Relaxation.SparsityTerm"><code>SparsityTerm</code></a> implementations allow to customize the iteration procedure by the keyword arguments. The arguments <code>objective</code>, <code>zero</code>, <code>nonneg</code>, and <code>psd</code> can be boolean values (<code>false</code> means that these elements will not contribute to the iteration, <code>true</code> that they will). <code>zero</code>, <code>nonneg</code>, and <code>psd</code> can also be <code>AbstractSet</code>s of integers, indicating that only the constraints with the indices specified in the set will contribute to the iteration. This all implies that the method used for their iteration will be given by <code>method</code>. Custom methods can be assigned if the parameters are set to a <a href="reference.html#PolynomialOptimization.Relaxation.TermMode"><code>TermMode</code></a> or a vector of <code>TermMode</code>s.</p><p>The parameter <code>method</code> therefore determines the default that is assigned to the elements, and if not specified, it will be determined by the default method with which <code>relaxation</code> was constructed. Instead of a single <code>TermMode</code>, <code>method</code> may also be a vector successively assigning modes to the objective, the first zero constraints, ..., the nonnegative constraints, the psd constraints (eliminating the need for the other keywords).</p><p>The parameter <code>varclique_methods</code> instead allows to assign custom methods to individual variable cliques. Note that a variable clique can cover the objective and all constraints; in the case of conflicting assignments, the clique assignment takes precedence (but a clique mode may also be <code>missing</code> individually, in which case the default is taken).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/relaxations/sparse/Term.jl#L483-L502">source</a></section></article><h2 id="Optimization-and-problem-solutions"><a class="docs-heading-anchor" href="#Optimization-and-problem-solutions">Optimization and problem solutions</a><a id="Optimization-and-problem-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-and-problem-solutions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation}" href="#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation}"><code>PolynomialOptimization.Solver.poly_optimize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poly_optimize([method, ]relaxation::AbstractRelaxation; verbose=false,
    representation=RepresentationPSD(), [precision::Real], kwargs...)</code></pre><p>Optimize a relaxed polynomial optimization problem that was construced via <a href="reference.html#PolynomialOptimization.poly_problem-Tuple{P} where P&lt;:AbstractPolynomialLike"><code>poly_problem</code></a> and then wrapped into an <a href="reference.html#PolynomialOptimization.Relaxation.AbstractRelaxation"><code>AbstractRelaxation</code></a>. Returns a <a href="reference.html#PolynomialOptimization.Result"><code>Result</code></a> object.</p><p>Instead of modeling the moment/SOS matrices as positive semidefinite, other representations such as the (scaled) diagonally dominant description are also possible. The <code>representation</code> parameter can be used to define a representation that is employed for the individual groupings. This may either be an instance of a <a href="reference.html#PolynomialOptimization.Solver.RepresentationMethod"><code>RepresentationMethod</code></a> - which requires the method to be independent of the dimension of the grouping - or a callable. In the latter case, it will be passed as a first parameter an identifier<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> of the current conic variable, and as a second parameter the side dimension of its matrix. The method must then return a <a href="reference.html#PolynomialOptimization.Solver.RepresentationMethod"><code>RepresentationMethod</code></a> instance.</p><p><code>verbose=true</code> will enable logging; this will print basic information about the relaxation itself as well as instruct the solver to output a detailed log. The PSD block sizes reported accurately represent the side dimensions of semidefinite variables and how many of these variables appear. The free block sizes are only very loose upper bounds on the maximal number of equality constraints that will be constructed by multiplying two elements from a block, as duplicates will be ignored. Any additional keyword argument is passed on to the solver.</p><p>For a list of supported methods, see <a href="includedsolvers.html#solvers_poly_optimize">the solver reference</a>. If <code>method</code> is omitted, the default solver is used. Note that this depends on the loaded solver packages, and possibly also their loading order if no preferred solver has been loaded.</p><p>The keyword arguments are different for every solver; in general, if the solver permits access to its configuration options via a name, each option can be passed as a keyword argument. If the solver requires the use of integer constants (that are defined in some solver package), the options must be passed in the <code>parameters</code> keyword argument, which must be an iterable of pair-like elements. As the parameters for each solver are quite different, the optional <code>precision</code> argument will set some characteristic options related to the precision of the result (feasibility measures, duality gap) all to this value unless they are overwritten explicitly. However, be aware that each solver defines its own set of termination criteria, so the meaning of <code>precision</code> is not very strict.</p><p>See also <a href="reference.html#PolynomialOptimization.Solver.RepresentationIAs"><code>RepresentationIAs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/Optimization.jl#L18-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Problem, Vararg{Any}}" href="#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Problem, Vararg{Any}}"><code>PolynomialOptimization.Solver.poly_optimize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poly_optimize([method, ]problem::Problem[, degree::Int]; kwargs...)</code></pre><p>Construct a <a href="reference.html#PolynomialOptimization.Relaxation.Dense"><code>Relaxation.Dense</code></a> by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/Optimization.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.poly_optimize-Tuple{PolynomialOptimization.Result}" href="#PolynomialOptimization.Solver.poly_optimize-Tuple{PolynomialOptimization.Result}"><code>PolynomialOptimization.Solver.poly_optimize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poly_optimize(result::Result; [representation=IterateRepresentation(), ]kwargs...)</code></pre><p>Re-optimizes a previously optimized polynomial optimization problem. This is usually pointless, as the employed optimizers will find globally optimal solutions. However, this method allows to change the representation used for the constraints (or objective). If <code>representation</code> is a callable, it will now receive as a third parameter the type of the <a href="reference.html#PolynomialOptimization.Solver.RepresentationMethod"><code>RepresentationMethod</code></a> used before for this constraint<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>, and as a fourth parameter the associated SOS matrix from the previous optimization. For efficiency reasons, this should only be used for changes that preserve the structure of the representation (i.e., whether it was PSD/DD/SDD and if its rotation was diagonal, triangular, or dense). If a structure non-preserving change is made, the problem needs to be constructed from scratch. For non-diagonal rotations, consider using <a href="reference.html#PolynomialOptimization.Solver.RepresentationIAs"><code>RepresentationIAs</code></a> in the first optimization.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The internal state of the previous solver run will be re-used whenever possible. Therefore, no further data may be queried from the previous result afterwards, unless a re-optimization from scratch was necessary. While <code>result</code> will still be able to offer information about the relaxation, method, time, status, and objective value, moment matrices can only be accessed if they were already cached (i.e., accessed) before. Existing SOS certificates of the previous result will still be available, but new ones may not be constructed.</p></div></div><p>See also <a href="reference.html#PolynomialOptimization.IterateRepresentation"><code>IterateRepresentation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/Optimization.jl#L154-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.RepresentationMethod" href="#PolynomialOptimization.Solver.RepresentationMethod"><code>PolynomialOptimization.Solver.RepresentationMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RepresentationMethod{M,Complex}</code></pre><p>Union type that defines how the optimizer constraint σ ⪰ 0 is interpreted. Usually, &quot;⪰&quot; means positive semidefinite; however, there are various other possibilities giving rise to weaker results, but scale more favorably. The following methods are supported:</p><ul><li><a href="reference.html#PolynomialOptimization.Solver.RepresentationPSD"><code>RepresentationPSD</code></a></li><li><a href="reference.html#PolynomialOptimization.Solver.RepresentationSDD"><code>RepresentationSDD</code></a></li><li><a href="reference.html#PolynomialOptimization.Solver.RepresentationDD"><code>RepresentationDD</code></a></li></ul><p>See also <a href="reference.html#PolynomialOptimization.Solver.RepresentationIAs"><code>RepresentationIAs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/solver/Representations.jl#L55-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.RepresentationPSD" href="#PolynomialOptimization.Solver.RepresentationPSD"><code>PolynomialOptimization.Solver.RepresentationPSD</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RepresentationPSD &lt;: RepresentationMethod</code></pre><p>Model the constraint &quot;σ ⪰ 0&quot; as a positive semidefinite cone membership, <code>σ ∈ PSD</code>. This is the strongest possible model, but the most resource-intensive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/solver/Representations.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.RepresentationSDD" href="#PolynomialOptimization.Solver.RepresentationSDD"><code>PolynomialOptimization.Solver.RepresentationSDD</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RepresentationSDD([u]; complex=true) &lt;: RepresentationMethod</code></pre><p>Model the constraint &quot;σ ⪰ 0&quot; as a membership in the scaled diagonally dominant cone, <span>$\sigma = u^\dagger Q u$</span> for some <code>Q ∈ SDD</code>. The matrix <code>u</code> is by default an identity of any dimension; however, usually, care must be taken to have a matrix of suitable dimension. The membership <code>Q ∈ SDD</code> is achieved using the scaled diagonally dominant (dual) cone directly or (rotated) quadratic cones.</p><p>If σ is a Hermitian matrix, a complex-valued scaled diagonally dominant (dual) cone will be used, if supported. If not, fallbacks to the (rotated) quadratic cones are used; however, if <code>complex=false</code> and the ordinary scaled diagonally dominant (dual) cone is supported, rewrite the matrix as a real one and then use the real-valued cone. This is usually never advisable, as the rotated quadratic cone always works on the complex data. Note that if rewritten, <code>u</code> must be real-valued and have twice the side dimension of the complex-valued matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/solver/Representations.jl#L9-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.RepresentationDD" href="#PolynomialOptimization.Solver.RepresentationDD"><code>PolynomialOptimization.Solver.RepresentationDD</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RepresentationDD([u]; complex=true) &lt;: RepresentationMethod</code></pre><p>Model the constraint &quot;σ ⪰ 0&quot; as a membership in the diagonally dominant cone, <span>$\sigma = u^\dagger Q u$</span> for some <code>Q ∈ DD</code>. The matrix <code>u</code> is by default an identity of any dimension; however, usually, care must be taken to have a matrix of suitable dimension. The membership <code>Q ∈ DD</code> is achieved using the diagonally dominant (dual) cone directly, <span>$\ell_1$</span>- or <span>$\ell_\infty$</span>-norm cones or linear inequalities; slack variables will be added as necessary.</p><p>If σ is a Hermitian matrix, a complex-valued diagonally dominant (dual) cone will be used, if supported. If not, fallbacks will first try quadratic cones on the complex-valued data, and if this is also not supported, rewrite the matrix as a real one and then apply the real-valued DD constraint. By setting the <code>complex</code> parameter to <code>false</code>, the rewriting to a real matrix will always be used, regardless of complex-valued solver support. Note that if rewritten, <code>u</code> must be real-valued and have twice the side dimension of the complex-valued matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/solver/Representations.jl#L31-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.RepresentationIAs" href="#PolynomialOptimization.Solver.RepresentationIAs"><code>PolynomialOptimization.Solver.RepresentationIAs</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RepresentationIAs(r::Type{RepresentationDD,RepresentationSDD},
    m::Type{&lt;:AbstractMatrix}=UpperTriangular; complex=true)</code></pre><p>Default callable that will instantiate a correctly-sized representation of type <code>r</code> with an identity rotation that is, however, not recognized as a diagonal rotation but as type <code>m</code> instead. Use this type in the first call to <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a> if you want to re-optimize the problem afterwards with rotations of type <code>m</code>. The default for <code>m</code>, <code>UpperTriangular</code>, is suitable for the automatic Cholesky-based reoptimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/solver/Representations.jl#L69-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Result" href="#PolynomialOptimization.Result"><code>PolynomialOptimization.Result</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Result</code></pre><p>Result of a polynomial optimization, returned by calling <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a> on an <a href="reference.html#PolynomialOptimization.Relaxation.AbstractRelaxation"><code>AbstractRelaxation</code></a>. A <code>Result</code> struct <code>r</code> contains information about</p><ul><li>the relaxation employed for the optimization (<code>r.relaxation</code>)</li><li>the optimized problem (available via <a href="reference.html#PolynomialOptimization.poly_problem-Tuple{PolynomialOptimization.Result}"><code>poly_problem</code></a>)</li><li>the used method (<code>r.method</code>)</li><li>the time required for the optimization in seconds (<code>r.time</code>)</li><li>the status of the solver (<code>r.status</code>), which also depends on the solver type. Use <a href="backend.html#LinearAlgebra.issuccess-Tuple{Val, Any}-backend"><code>issuccess</code></a> to check whether this is a successful status.</li><li>the returned primal value of the solver (<code>r.objective</code>), which, if the status was successful, is a lower bound to the true minimum</li><li>the moment information in vector form (<code>r.moments</code>), which allows to construct a <a href="reference.html#PolynomialOptimization.moment_matrix">moment matrix</a>, extract solutions (<a href="reference.html#PolynomialOptimization.poly_all_solutions"><code>poly_all_solutions</code></a> or <a href="reference.html#PolynomialOptimization.poly_solutions"><code>poly_solutions</code></a>), and an <a href="reference.html#PolynomialOptimization.optimality_certificate">optimality certificate</a>.</li></ul><p>This type is not exported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/Result.jl#L183-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.issuccess-Tuple{PolynomialOptimization.Result}" href="#LinearAlgebra.issuccess-Tuple{PolynomialOptimization.Result}"><code>LinearAlgebra.issuccess</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">issuccess(r::Result)</code></pre><p>Returns <code>true</code> if the solver successfully solved the relaxation and provided a solution, and <code>false</code> otherwise.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Solvers often do not have just a single &quot;good&quot; status code, but also &quot;near successes&quot;. Whether they will return <code>true</code> or <code>false</code> is dependent on the implementation. The <code>status</code> field of the result is always available to get the original return value.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/Result.jl#L246-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.poly_problem-Tuple{PolynomialOptimization.Result}" href="#PolynomialOptimization.poly_problem-Tuple{PolynomialOptimization.Result}"><code>PolynomialOptimization.poly_problem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poly_problem(r::Result)</code></pre><p>Returns the problem that was associated with the optimization result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/Result.jl#L258-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.optimality_certificate" href="#PolynomialOptimization.optimality_certificate"><code>PolynomialOptimization.optimality_certificate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optimality_certificate(result::Result, ϵ=1e-6)</code></pre><p>This function applies the flat extension/truncation criterion to determine whether the optimality of the given problem can be certified, in which case it returns <code>:Optimal</code>. If no such certificate is found, the function returns <code>:Unknown</code>. The criterion is meaningless for sparse problems or if a full basis is not available. The parameter <code>ϵ</code> controls the bound below which singular values are considered to be zero, and its negative below which eigenvalues are considered to be negative.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/OptimalityCertificate.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.poly_all_solutions" href="#PolynomialOptimization.poly_all_solutions"><code>PolynomialOptimization.poly_all_solutions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poly_all_solutions([method, ]result::Result, args...; verbose=false, rel_threshold=100,
    abs_threshold=Inf, kwargs...)</code></pre><p>Obtains a vector of all the solutions to a previously optimized problem; then iterates over all of them and grades and sorts them by their badness. Every solution of the returned vector is a tuple that first contains the optimal point and second the badness at this point. Solutions that are <code>rel_threshold</code> times worse than the best solution or worse than <code>abs_threshold</code> will be dropped from the result.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a>, <a href="reference.html#PolynomialOptimization.poly_solutions"><code>poly_solutions</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/solutions/SolutionExtraction.jl#L143-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.poly_solutions" href="#PolynomialOptimization.poly_solutions"><code>PolynomialOptimization.poly_solutions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poly_solutions([method, ]result::Result, args...; verbose, kwargs...)</code></pre><p>Extracts solutions from a polynomial optimization result using the method <code>method</code>. Depending on the chosen method, the result may be an iterator or a vector. Consult the documentation of the methods for further information. If <code>method</code> is omitted, a default method will be chosen according to the relaxation that was used for the optimization.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a>, <a href="reference.html#PolynomialOptimization.poly_all_solutions"><code>poly_all_solutions</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/solutions/SolutionExtraction.jl#L32-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.poly_solution_badness" href="#PolynomialOptimization.poly_solution_badness"><code>PolynomialOptimization.poly_solution_badness</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poly_solution_badness(result::Result, solution)</code></pre><p>Determines the badness of a solution by comparing the value of the objective with the value according to the optimization given in <code>result</code>, and also by checking the violation of the constraints. The closer the return value is to zero, the better. If the return value is too large, <code>solution</code> probably has nothing to do with the actual solution.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a>, <a href="reference.html#PolynomialOptimization.poly_solutions"><code>poly_solutions</code></a>, <a href="reference.html#PolynomialOptimization.poly_all_solutions"><code>poly_all_solutions</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/solutions/SolutionExtraction.jl#L111-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.moment_matrix" href="#PolynomialOptimization.moment_matrix"><code>PolynomialOptimization.moment_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">moment_matrix(problem::Result; max_deg=Inf, prefix=1)</code></pre><p>After a problem has been optimized, this function assembles the associated moment matrix (possibly by imposing a degree bound <code>max_deg</code>, and possibly multiplying each monomial by the monomial or variable <code>prefix</code>, which does not add to <code>max_deg</code>). Note that <code>prefix</code> has to be a valid <code>IntMonomial</code> or <code>IntVariable</code> of appropriate type.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a>, <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/MomentMatrix.jl#L13-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.MomentVector" href="#PolynomialOptimization.MomentVector"><code>PolynomialOptimization.MomentVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MomentVector(relaxation::AbstractRelaxation, values::AbstractVector{R} where {R&lt;:Real})</code></pre><p><code>MomentVector</code> is a representation of the result of a polynomial optimization. It contains all the values of the moments that were present in the optimization problem. This vector can be indexed in two ways:</p><ul><li>linearly, which will just transparently yield what linearly indexing <code>values</code> would yield</li><li>with a monomial (or multiple monomials, which means that the product of all the monomials is to be considered), which will yield the value that is associated with this monomial; if the problem was complex-valued, this will be a <code>Complex{R}</code>.</li></ul><p>In order to get an association-like iterator, use <a href="reference.html#PolynomialOptimization.MomentAssociation"><code>MomentAssociation</code></a>.</p><p>This type is not exported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/Result.jl#L5-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.MomentAssociation" href="#PolynomialOptimization.MomentAssociation"><code>PolynomialOptimization.MomentAssociation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MomentAssociation(m::MomentVector)</code></pre><p>Creates a associative iterator over the moment vector <code>m</code> that, upon iteration, returns <code>Pair</code>s assigning values to monomials.</p><p>This type is not exported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/Result.jl#L91-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.SOSCertificate" href="#PolynomialOptimization.SOSCertificate"><code>PolynomialOptimization.SOSCertificate</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SOSCertificate(result::Result)</code></pre><p>Construct a SOS certificate from a given optimization result. The returned object will pretty-print to show the decomposition of the optimization problem in terms of a positivstellensatz. To obtain the polynomials for the individual terms, the object can be indexed. The first index is one of <code>:objective</code>, <code>:zero</code>, <code>:nonneg</code>, <code>:psd</code>; the second index is the number of the desired element (omitted for <code>:objective</code>); the last index is the index of the desired grouping due to sparsity. If the last index is omitted, a vector over all groupings is returned.</p><p>The returned vectors of polynomials are, for <code>:objective</code> and <code>:nonneg</code>, to be summed over their squares; for <code>:psd</code>, the returned matrix <code>m</code> of polynomials is to be left-multiplied with its adjoint: <code>m&#39; * m</code>. For <code>:zero</code>, a single polynomial is returned. If all these operations are carried out while multiplying with the corresponding prefactors (i.e., the constraints themselves), the resulting polynomial should be equal to the original objective. Note that this need not be the case; only if the relaxation level was sufficient will a SOS certificate in fact be valid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/SOSCertificate.jl#L256-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.sos_matrix" href="#PolynomialOptimization.sos_matrix"><code>PolynomialOptimization.sos_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sos_matrix(relaxation::AbstractRelaxation, state[, constraint])</code></pre><p>Extracts the SOS matrices associated with a solved relaxation. A <code>constraint</code> is identified in the same way as the first argument that is passed to a <a href="reference.html#PolynomialOptimization.Solver.RepresentationMethod"><code>RepresentationMethod</code></a> (see <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>). Short forms are allowed when there is just a single grouping. Usually, a <a href="reference.html#PolynomialOptimization.SOSCertificate"><code>SOSCertificate</code></a> is more desirable than the construction of individual SOS matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/SOSCertificate.jl#L55-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IterateRepresentation" href="#PolynomialOptimization.IterateRepresentation"><code>PolynomialOptimization.IterateRepresentation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IterateRepresentation(; keep_structure=false)</code></pre><p>Default iteration method for DD and SDD representations. This is will perform a Cholesky decomposition of the old SOS matrix and use it as the new rotation, ensuring that results never get worse (at least in theory; since a positive definite SOS matrix is only guaranteed up to a certain tolerance, bad things could still happen).</p><p>Note that the resulting rotation matrix will be upper triangular, which may break a previous structure. By setting <code>keep_structure</code> to <code>true</code>, the structure will be preserved (if it was diagonal, this would mean keeping only the diagonal of the Cholesky factor, with no theoretical guarantees, not even about convergence; if it was lower triangular the adjoint will be taken, which will <em>not</em> give any convergence guarantees, as the rotated DD/SDD cone is implemented with respect to the upper triangular factorization).</p><p>See also <a href="reference.html#PolynomialOptimization.Solver.poly_optimize-Tuple{PolynomialOptimization.Result}"><code>poly_optimize</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/optimization/Optimization.jl#L108-L122">source</a></section></article><h2 id="Newton-polytope-construction-(manually)"><a class="docs-heading-anchor" href="#Newton-polytope-construction-(manually)">Newton polytope construction (manually)</a><a id="Newton-polytope-construction-(manually)-1"></a><a class="docs-heading-anchor-permalink" href="#Newton-polytope-construction-(manually)" title="Permalink"></a></h2><p>Note that using these functions is usually not necessary; construct a <a href="reference.html#PolynomialOptimization.Relaxation.Newton"><code>Newton</code></a> relaxation instead.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Newton.halfpolytope" href="#PolynomialOptimization.Newton.halfpolytope"><code>PolynomialOptimization.Newton.halfpolytope</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">halfpolytope(method, poly; verbose=false, preprocess_quick=true,
    preprocess_randomized=false, preprocess_fine=false, preprocess=nothing,
    filepath=nothing, parameters...)</code></pre><p>Calculates the Newton polytope for the sum of squares optimization of a given objective, which is half the Newton polytope of the objective itself. This requires the availability of a linear solver. For a list of supported solvers, see <a href="backend.html#solvers_newton">the solver reference</a>.</p><p>There are three preprocessing methods which can be turned on individually or collectively using <code>preprocess</code>; depending on the problem, they may reduce the amount of time that is required to construct the convex hull of the full Newton polytope:</p><ul><li><code>preprocess_quick</code> is the Akl-Toussaint heuristic. Every monomial will be checked against a linear program that scales as the number of variables in the objective. This is enabled by default.</li><li><code>preprocess_randomized</code> performs a reduction of the possible number of monomials that comprise the convex hull by picking smaller random subsets of them and eliminating entries in the subset that can be expressed by other entries. This is a good idea if the number of candidate monomials for the vertices of the convex hull is huge (so that <code>preprocess_fine</code> will take too long) but also very redundant. The final polish can be done by enabling both this and the following preprocessing option. Randomized reduction will use multithreading if possible.</li><li><code>preprocess_fine</code> performs an extensive reduction of the possible number of monomials that comprise the convex hull. Every monomial will be checked against a linear program that scales as the number of monomials in the objective (though it might become more efficient when monomials are ruled out).</li></ul><p>After preprocessing is done, the monomials in the half Newton polytope are constructed efficiently subject to a simple min/max-degree constraint using <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.MultivariateExponents.ExponentsMultideg"><code>ExponentsMultideg</code></a> and taken over into the basis if they are contained in the convex polytope whose vertices were determined based on the objective and preprocessing; this is done by performing a linear program for each candidate monomial.</p><p>The <code>parameters</code> will be passed on to the linear solver in every case (preprocessing and construction).</p><div class="admonition is-info"><header class="admonition-header">Multithreading</header><div class="admonition-body"><p>For large initial sets of monomials (≥ 10⁴), the final construction will use multithreading if possible. Make sure to start Julia with an appropriate number of threads configured.</p></div></div><div class="admonition is-success"><header class="admonition-header">Distributed computing</header><div class="admonition-body"><p>This function is capable of using MPI for multi-node distributed computing. For this, make sure to start Julia using <code>mpiexec</code>, appropriately configured; then load the <code>MPI</code> package in addition to <code>PolynomialOptimization</code> (this is required for distributed computing to work). If <code>MPI.Init</code> was not called before, <code>PolynomialOptimization</code> will do it for you. This function is compatible with the MPI thread level <code>MPI.THREAD_FUNNELED</code> if multithreading is used in combination with MPI. Currently, only the main function will use MPI, not the preprocessing.</p><p>Note that the function will assume that each MPI worker has the same number of threads available. Further note that Julia&#39;s GC works in a multithreaded context using the SIGSEG signal. This is known to cause problems among all MPI backends, which can usually be fixed by using the most recent version of MPI and setting some environment variables. Not all of these settings are incorporated into the MPI package yet. For OpenMPI and Intel MPI, set <code>ENV[&quot;IPATH_NO_BACKTRACE&quot;] = &quot;1&quot;</code>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Verbose output</header><div class="admonition-body"><p>The <code>verbose</code> option generates very helpful output to observe the current progress. It also works in a multithreaded and distributed context. However, consider the fact that providing these messages requires additional computational and communication effort and should not be enabled when speed matters.</p></div></div><div class="admonition is-success"><header class="admonition-header">Interrupting the computation/Large outputs</header><div class="admonition-body"><p>If you expect the final Newton basis to be very large, so that keeping everything in memory (potentially in parallel) might be troublesome, the option <code>filepath</code> allows to instead write the output to a file. This is also useful if the process of determining the polytope is aborted, as it can be resumed from its current state (also in a multithreaded or multiprocessing context) if the same file name is passed to <code>filepath</code>, provided the Julia configuration (number of threads, number of processes) was the same at any time. Make sure to always delete the output files if you compute with a different configuration or the results will probably be corrupt!</p><p>Using this option will create one (or multiple, if multithreading/multiprocessing is used) file that has the file name <code>filepath</code> with the extension <code>.out</code>, and for every <code>.out</code> file also a corresponding <code>.prog</code> file that captures the current status. The <code>.out</code> file(s) will hold the resulting basis in a binary format, the <code>.prog</code> file is a small indicator required for resuming the operation after an abort. This function will return <code>true</code> when it is finished and the data was stored to a file; it will <em>not</em> load the actual data. To do so, use <a href="reference.html#PolynomialOptimization.Newton.halfpolytope_from_file"><code>halfpolytope_from_file</code></a> in a separate step, which can also tell you exactly how much memory will be required for this operation.</p></div></div><p>See also <a href="reference.html#PolynomialOptimization.Newton.halfpolytope_from_file"><code>halfpolytope_from_file</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/newton/Newton.jl#L15-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Newton.halfpolytope_from_file" href="#PolynomialOptimization.Newton.halfpolytope_from_file"><code>PolynomialOptimization.Newton.halfpolytope_from_file</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">halfpolytope_from_file(filepath, objective; estimate=false, verbose=false)</code></pre><p>Constructs the Newton polytope for the sum of squares optimization of a given objective, which is half the Newton polytope of the objective itself. This function does not do any calculation, but instead loads the data that has been generated using <a href="reference.html#PolynomialOptimization.Newton.halfpolytope"><code>halfpolytope</code></a> with the given <code>filepath</code> on the given <code>objective</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function will not take into account the current Julia configuration, but instead lists all files that are compatible with the given filepath. This allows you to, e.g., create the data in a multi-node context with moderate memory requirements per CPU, but load it later in a single process with lots of memory available (though note that the integer size must match; data that was created on a 64-bit system can be reconstructed only on a 64-bit system). However, this requires you not to have multiple files from different configurations running.</p><p>The function ignores the <code>.prog</code> files and just assembles the output of the <code>.out</code> files, so it does not check whether the calculation actually finished.</p></div></div><div class="admonition is-success"><header class="admonition-header">Memory requirements</header><div class="admonition-body"><p>If the parameter <code>estimate</code> is set to <code>true</code>, the function will only analyze the size of the files and from this return an estimation of how many monomials the output will contain. This is an overestimation, as it might happen that the files contain a small number of duplicates if the calculation was interrupted and subsequently resumed (although this is not very likely and the result should be pretty accurate).</p></div></div><p>See also <a href="reference.html#PolynomialOptimization.Newton.halfpolytope"><code>halfpolytope</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/fd67bd1ae5324788e591b9bb3be4e194ec2d5f93/src/newton/Files.jl#L1-L25">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>This identifier will be a tuple, where the first element is a symbol - either <code>:objective</code>, <code>:nonneg</code>, or <code>:psd</code> - to   indicate the general reason why the variable is there. The second element is an <code>Int</code> denoting the index of the   constraint (and will be undefined for the objective, but still present to avoid extra compilation). The last element   is an <code>Int</code> denoting the index of the grouping within the constraint/objective.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Roughly, as the exact type is not known. For sure, it will be possible to distinguish between   <a href="reference.html#PolynomialOptimization.Solver.RepresentationPSD"><code>RepresentationPSD</code></a>, <a href="reference.html#PolynomialOptimization.Solver.RepresentationDD"><code>RepresentationDD</code></a>, and <a href="reference.html#PolynomialOptimization.Solver.RepresentationSDD"><code>RepresentationSDD</code></a>. The matrix type will not be   concrete, but either <code>Union{&lt;:UniformScaling,&lt;:Diagonal}</code> if a diagonal representation was used before,   <code>UpperOrUnitUpperTriangular</code>, <code>LowerOrUnitLowerTriangular</code>, or <code>Matrix</code> else. The complex identification will be <code>true</code>   if a complex-valued cone was used and <code>false</code> else (where during specification, it could also have been <code>true</code> for   real-valued data, which would simply be ignored). In any case, the third parameter can be used as a constructor accepting   (unless it is for <a href="reference.html#PolynomialOptimization.Solver.RepresentationPSD"><code>RepresentationPSD</code></a>) the new rotation matrix as parameter. This is recommended, as in this way   the <code>complex</code> value cannot change back to <code>true</code> for real-valued data, which would be interpreted as a change in   structure, even if it is not.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="guide.html">« Walkthrough</a><a class="docs-footer-nextpage" href="includedsolvers.html">Supported solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Tuesday 1 April 2025 15:45">Tuesday 1 April 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
