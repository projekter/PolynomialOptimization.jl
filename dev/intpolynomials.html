<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>IntPolynomials · PolynomialOptimization.jl</title><meta name="title" content="IntPolynomials · PolynomialOptimization.jl"/><meta property="og:title" content="IntPolynomials · PolynomialOptimization.jl"/><meta property="twitter:title" content="IntPolynomials · PolynomialOptimization.jl"/><meta name="description" content="Documentation for PolynomialOptimization.jl."/><meta property="og:description" content="Documentation for PolynomialOptimization.jl."/><meta property="twitter:description" content="Documentation for PolynomialOptimization.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">PolynomialOptimization.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="guide.html">Walkthrough</a></li><li><a class="tocitem" href="reference.html">Reference</a></li><li><a class="tocitem" href="includedsolvers.html">Supported solvers</a></li><li><a class="tocitem" href="backend.html">Backend</a></li><li><a class="tocitem" href="auxreference.html">Reference of auxilliaries</a></li><li class="is-active"><a class="tocitem" href="intpolynomials.html">IntPolynomials</a><ul class="internal"><li><a class="tocitem" href="#AbstractExponents"><span>AbstractExponents</span></a></li><li><a class="tocitem" href="#Exponent-set-types"><span>Exponent set types</span></a></li><li><a class="tocitem" href="#Working-with-exponents"><span>Working with exponents</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li><li><a class="tocitem" href="#Limitations"><span>Limitations</span></a></li><li><a class="tocitem" href="#The-MultivariatePolynomials-interface"><span>The MultivariatePolynomials interface</span></a></li><li><a class="tocitem" href="#Implementation-peculiarities"><span>Implementation peculiarities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="intpolynomials.html">IntPolynomials</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="intpolynomials.html">IntPolynomials</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/projekter/PolynomialOptimization.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/projekter/PolynomialOptimization.jl/blob/main/docs/src/intpolynomials.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="IntPolynomials"><a class="docs-heading-anchor" href="#IntPolynomials">IntPolynomials</a><a id="IntPolynomials-1"></a><a class="docs-heading-anchor-permalink" href="#IntPolynomials" title="Permalink"></a></h1><p><code>PolynomialOptimization</code> allows data in the form of any implementation that supports the <a href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl"><code>MultivariatePolynomials</code></a> interface. However, it does not keep the data in this way, which would not be particularly efficient. Instead, it is converted into an internal format, the <code>IntPolynomial</code>. It offers very compact storage (in some way even more compact than <a href="https://github.com/YingboMa/SIMDPolynomials.jl"><code>SIMDPolynomials</code></a>) and is particularly focused on being as allocation-free as possible - which means that once the original polynomials were created, at no further stage in processing the polynomials or monomial bases will any allocations be done.</p><h2 id="AbstractExponents"><a class="docs-heading-anchor" href="#AbstractExponents">AbstractExponents</a><a id="AbstractExponents-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractExponents" title="Permalink"></a></h2><p>For this, we first define a basic set of exponents which can occur in our monomial; this is a subtype of <a href="intpolynomials.html#AbstractExponents"><code>AbstractExponents</code></a>. Such a set of exponents is always parameterized by the number of variables and by the integer data type that contains the index of the monomials in the set. By default, this is <code>UInt</code>, but any Integer descendant can be chosen. Note that with <span>$n$</span> variables (complex and conjugate variables counted separately) of maximum degree <span>$d$</span>, the datatype must be able to hold the value <span>$\binom{n + d}{n}$</span>. In the typical scenario with not too high degrees, machine data types should be sufficient (say, <span>$d = 4$</span>, then even <code>UInt32</code> can hold up to 564 variables, and with <code>UInt64</code>, more than <span>$10^5$</span> variables are possible). A monomial vector is then either a complete cover of a degree-bound exponent set or a finite subset of any exponent set. It needs no extra space apart from the description of the exponent set itself if it is a complete cover, and only the space required to describe the subindices (they need not necessarily be a vector, they can also be a range) if it is a subset.</p><h2 id="Exponent-set-types"><a class="docs-heading-anchor" href="#Exponent-set-types">Exponent set types</a><a id="Exponent-set-types-1"></a><a class="docs-heading-anchor-permalink" href="#Exponent-set-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractExponents{N,I}</code></pre><p>Abstract supertype for all collections of multivariate exponents in <code>N</code> variables (<code>N &gt; 0</code>). Every collection is iterable (both using a default lazy iteration and a mutable iteration into a vector by means of <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.MultivariateExponents.iterate!-Tuple{AbstractVector{Int64}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents}"><code>iterate!</code></a> or <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.MultivariateExponents.veciter-Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents, AbstractVector{Int64}}"><code>veciter</code></a>) and indexable (return a lazy collection of exponents) with index type <code>I</code>. The collection has a length if it is finite; it is never empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponentsUnbounded" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponentsUnbounded"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponentsUnbounded</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractExponentsUnbounded{N,I} &lt;: AbstractExponents{N,I}</code></pre><p>Abstract supertype for unbounded collections of multivariate exponents. These collections do not have a length; they are infinite. Their cache is always initialized incrementally as required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponentsUnbounded.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponentsDegreeBounded" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponentsDegreeBounded"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponentsDegreeBounded</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractExponentsDegreeBounded{N,I} &lt;: AbstractExponents{N,I}</code></pre><p>Abstract supertype for finite collections of multivariate exponents, bounded by their degrees. These collections have a length; they also provide at least the fields <code>mindeg</code> and <code>maxdeg</code> that describe (a superset of) the covered degree range. Their cache is always initialized completely when required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponentsDegreeBounded.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.ExponentsAll" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.ExponentsAll"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.ExponentsAll</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExponentsAll{N,I}()</code></pre><p>Represents an index range for a fixed number of variables <code>N</code> without any degree bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/ExponentsAll.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.ExponentsDegree" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.ExponentsDegree"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.ExponentsDegree</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExponentsDegree{N,I}(mindeg::Integer, maxdeg::Integer)</code></pre><p>Represents an exponent range that is restricted by a bound on the total degree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/ExponentsDegree.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.ExponentsMultideg" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.ExponentsMultideg"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.ExponentsMultideg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExponentsMultideg{N,I}(mindeg::Integer, maxdeg::Integer,
    minmultideg::AbstractVector, maxmultideg::AbstractVector)</code></pre><p>Represents an exponent range that is restricted both by a global bound on the degree and by individual bounds on the variable degrees. Note that the vectors must not be used afterwards, and the constructor may clip maxmultideg to be no larger than maxdeg in each entry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/ExponentsMultidegree.jl#L12-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.indextype" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.indextype"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.indextype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">indextype(e)</code></pre><p>Returns the index type of an instance or subtype of <a href="intpolynomials.html#AbstractExponents"><code>AbstractExponents</code></a>. This function is not exported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L48-L52">source</a></section></article><h2 id="Working-with-exponents"><a class="docs-heading-anchor" href="#Working-with-exponents">Working with exponents</a><a id="Working-with-exponents-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-exponents" title="Permalink"></a></h2><p>Exponent sets can be indexed and iterated. If consecutive elements are required, iteration is slightly faster, as indexing requires to determine the degree for every operation. However, in this case it is fastest to preallocate a vector that can hold the exponents and <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.MultivariateExponents.iterate!-Tuple{AbstractVector{Int64}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents}"><code>iterate!</code></a> with mutation of this vector, or use the <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.MultivariateExponents.veciter-Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents, AbstractVector{Int64}}"><code>veciter</code></a> wrapper for this task:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.iterate!-Tuple{AbstractVector{Int64}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents}" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.iterate!-Tuple{AbstractVector{Int64}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents}"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.iterate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iterate!(v::AbstractVector{Int}, e::AbstractExponents)</code></pre><p>Iterates through a set of exponents by maintaining an explicit representation of all exponents. This is slightly more efficient that the lazy iteration version if every exponent has to be accessed explicitly. Note that <code>v</code> must be initialized with a valid exponent combination in <code>e</code> (this may be done via <code>copyto!(v, first(e))</code>). The function returns <code>true</code> if successful and <code>false</code> if the end was reached.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L60-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.veciter-Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents, AbstractVector{Int64}}" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.veciter-Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents, AbstractVector{Int64}}"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.veciter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">veciter(e::AbstractExponents[, v::AbstractVector{Int}])</code></pre><p>Creates an iterator over exponents that stores its result in a vector. This results in zero-allocations per iteration (as the iteration over <code>e</code> also does), but is more efficient if every element in <code>e</code> must be accessed. If the vector <code>v</code> is given as an argument, the data will be stored in this vector. If the vector is omitted, it will be created once at the beginning of the iteration process. The vector must never be altered, as it also serves as the state for the iterator; therefore, the same iterator may also not be nested.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L102-L111">source</a></section></article><p>When working with individual indices or exponents, conversion functions are provided.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.exponents_to_index" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.exponents_to_index"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.exponents_to_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exponents_to_index(::AbstractExponents{N,I}, exponents,
    degree::Int=sum(exponents, init=0)[, report_lastexp::Int])</code></pre><p>Calculates the index of a monomial in <code>N</code> variables in an exponent set with exponents given by the iterable <code>exponents</code> (whose length should match <code>N</code>, else the behavior is undefined). The data type of the output is <code>I</code>. If <code>exponents</code> is not present in the exponent set, the result is <code>zero(I)</code>. <code>degree</code> must always match the sum of all elements in the exponent set, but if it is already known, it can be passed to the function. No validity check is performed on <code>degree</code>.</p><div class="admonition is-info"><header class="admonition-header">Truncated lengths</header><div class="admonition-body"><p>If the last argument <code>report_lastexp</code> is set to a value between <code>1</code> and <code>N</code>, the function will only consider the first <code>report_lastexp</code> exponents and return the largest index whose left exponents are compatible with those in <code>exponents</code> (whose length should still match <code>N</code>, unless <code>degree</code> is correctly specified manually). Again, if no such match can be found, the index is zero. If <code>report_lastexp</code> is set, the result will be a 2-tuple whose first entry is the index and whose second entry is the value of the last considered exponent, i.e. <code>exponents[report_lastexp]</code> if <code>exponents</code> is indexable.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L138-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.exponents_from_index-Union{Tuple{I}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{&lt;:Any, I}, I}} where I&lt;:Integer" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.exponents_from_index-Union{Tuple{I}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{&lt;:Any, I}, I}} where I&lt;:Integer"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.exponents_from_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exponents_from_index(::AbstractExponents{N,I}, index::I[, degree::Int])</code></pre><p>Calculates the exponents that are associated with the monomial index <code>index</code> in <code>N</code> variables within a given exponent set. The return value will be a lazy implementation of <code>AbstractVector{Int}</code> (though iterating is more efficient than indexing). <code>degree</code> must match the degree of the index, if it is specified.</p><p>See also <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.MultivariateExponents.degree_from_index-Union{Tuple{I}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I}, I}} where {N, I&lt;:Integer}"><code>degree_from_index</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/ExponentsIndices.jl#L24-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.exponents_sum" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.exponents_sum"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.exponents_sum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exponents_sum(e::AbstractExponents{N,I}, exponents...) -&gt; Tuple{I,Int}</code></pre><p>Calculates the index of the sum of all <code>exponents</code> within <code>e</code>. If the result cannot be found in <code>e</code>, the function will return zero. Returns the total degree as second entry in the tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L393-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.exponents_product" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.exponents_product"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.exponents_product</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exponents_product(e::AbstractExponents{N,I}, exponents, p::Integer) -&gt; Tuple{I,Int}</code></pre><p>Calculates the index of the product of the <code>exponents</code> with the number <code>p</code>. If the result cannot be found in <code>e</code>, the function will return zero. Returns the total degree as second entry in the tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L422-L427">source</a></section></article><p>Note that <code>exponents_from_index</code> returns a lazy implementation of an <code>AbstractVector{Int}</code>; if the same exponents must be accessed multple times, it might be beneficial to <code>collect</code> the result or copy it to a pre-allocated vector.</p><p>Further information can be obtained about one or two indices or exponent sets:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.degree_from_index-Union{Tuple{I}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I}, I}} where {N, I&lt;:Integer}" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.degree_from_index-Union{Tuple{I}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I}, I}} where {N, I&lt;:Integer}"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.degree_from_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">degree_from_index(::AbstractExponents{N,I}, index::I)</code></pre><p>Returns the degree that is associated with a given monomial index <code>index</code> in <code>N</code> variables. If the index was larger than the maximally allowed index in the exponent set, a degree larger than the maximal degree allowed in the iterator will be returned (not necessarily <code>lastindex +1</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L171-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.convert_index-Union{Tuple{IS}, Tuple{I}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, IS}, IS, Int64}} where {N, I&lt;:Integer, IS&lt;:Integer}" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.convert_index-Union{Tuple{IS}, Tuple{I}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, IS}, IS, Int64}} where {N, I&lt;:Integer, IS&lt;:Integer}"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.convert_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_index(target::AbstractExponents{N}, source::AbstractExponents{N,I},
    index::I[, degree::Int])</code></pre><p>Converts an index from an exponent set <code>source</code> to an exponent set <code>target</code>. <code>index</code> is always assumed to be a valid index for <code>source</code>, else the behavior is undefined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L244-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.compare_indices-Union{Tuple{I2}, Tuple{I1}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I1}, I1, Union{typeof(!=), typeof(&lt;), typeof(&lt;=), typeof(==), typeof(&gt;), typeof(&gt;=)}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I2}, I2, Int64}} where {N, I1&lt;:Integer, I2&lt;:Integer}" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.compare_indices-Union{Tuple{I2}, Tuple{I1}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I1}, I1, Union{typeof(!=), typeof(&lt;), typeof(&lt;=), typeof(==), typeof(&gt;), typeof(&gt;=)}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I2}, I2, Int64}} where {N, I1&lt;:Integer, I2&lt;:Integer}"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.compare_indices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compare_indices(e₁::AbstractExponents, index₁, op, e₂::AbstractExponents,
    index₂[, degree::Int])</code></pre><p>Compares two indices from two possibly different exponent sets. <code>degree</code>, if given, must be the common degree of both exponents); when <code>degree</code> is omitted, also different degrees are possible. Both indices are assumed to be valid for their respective exponent sets, else the behavior is undefined. However, it is not necessary that an index is also valid in the other&#39;s exponent set. If ẽ₁ and ẽ₂ denote the conversion of the indices to a common exponent set (say, <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.MultivariateExponents.ExponentsAll"><code>ExponentsAll</code></a>), then the result is <code>op(ẽ₁, ẽ₂)</code>. The only allowed values for <code>op</code> are <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L345-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==-Union{Tuple{I2}, Tuple{I1}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I1}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I2}}} where {N, I1&lt;:Integer, I2&lt;:Integer}" href="#Base.:==-Union{Tuple{I2}, Tuple{I1}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I1}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I2}}} where {N, I1&lt;:Integer, I2&lt;:Integer}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">a == b</code></pre><p>Compares whether two exponents with the same variable number are equal. Exponents with different index types are not considered equal.</p><p>See <a href="intpolynomials.html#Base.isequal-Union{Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N}}} where N"><code>isequal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L20-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isequal-Union{Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N}}} where N" href="#Base.isequal-Union{Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N}}} where N"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isequal(a, b)</code></pre><p>Compares whether two exponents with the same variable number are equal. Different index types are disregarded.</p><p>See <a href="intpolynomials.html#Base.:==-Union{Tuple{I2}, Tuple{I1}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I1}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I2}}} where {N, I1&lt;:Integer, I2&lt;:Integer}"><code>==</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L31-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.issubset-Union{Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N}}} where N" href="#Base.issubset-Union{Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N}}} where N"><code>Base.issubset</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">issubset(a, b)</code></pre><p>Checks whether the exponent set <code>a</code> is fully contained in <code>b</code>. Different index types are disregarded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L41-L45">source</a></section></article><p>Degree-bound exponent sets have a length:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponentsDegreeBounded}" href="#Base.length-Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponentsDegreeBounded}"><code>Base.length</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">length(e::AbstractExponentsDegreeBounded)</code></pre><p>Returns the total number of exponents present in <code>e</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponentsDegreeBounded.jl#L26-L30">source</a></section></article><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><p>The internal cache of exponents is extremely important for fast access. Unless the unsafe versions of the functions are used, it is always ensured that the cache is large enough to do the required operations; this is a quick check, but it can be elided using the unsafe versions. They, as well as the functions that allow direct access to the cache, must only be used if you know exactly what you are doing.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.index_counts" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.index_counts"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.index_counts</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">index_counts(unsafe, ::AbstractExponents{N,I})</code></pre><p>Returns the current <code>Matrix{I}</code> that holds the exponents counts for up to <code>N</code> variables in its <code>N+1</code> columns (in descending order, ending with zero variables), and for the maximal degrees in the rows (in ascending order, starting with zero). The result is neither guaranteed to be defined at all nor have the required form if the cache was not calculated before.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L126-L132">source</a></section><section><div><pre><code class="language-julia hljs">index_counts(::AbstractExponents{N,I}, degree::Integer) -&gt; Tuple{Matrix{I},Bool}</code></pre><p>Safe version of the above. If the boolean in the result is <code>true</code>, the matrix will have at least <code>degree+1</code> rows, i.e., all entries up to <code>degree</code> are present. If it is false, the requested degree is not present in the exponents and the matrix will have fewer rows. Note that <code>true</code> does not mean that the degree is actually present in the exponents, only that its information has been calculated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponentsUnbounded.jl#L33-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.exponents_from_index-Union{Tuple{I}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.Unsafe, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{&lt;:Any, I}, I, Int64}} where I&lt;:Integer" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.exponents_from_index-Union{Tuple{I}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.Unsafe, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{&lt;:Any, I}, I, Int64}} where I&lt;:Integer"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.exponents_from_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exponents_from_index(unsafe, ::AbstractExponents{N,I}, index::I[, degree::Int])</code></pre><p>Unsafe variant of <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.MultivariateExponents.exponents_from_index-Union{Tuple{I}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{&lt;:Any, I}, I}} where I&lt;:Integer"><code>exponents_from_index</code></a>: assumes that the cache for degree <code>degree</code> has already been populated, and that the exponent set contains <code>index</code>. If <code>degree</code> is omitted, it is calculated using the unsafe variant of <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.MultivariateExponents.degree_from_index-Union{Tuple{I}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.Unsafe, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I}, I}} where {N, I&lt;:Integer}"><code>degree_from_index</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/ExponentsIndices.jl#L9-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.degree_from_index-Union{Tuple{I}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.Unsafe, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I}, I}} where {N, I&lt;:Integer}" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.degree_from_index-Union{Tuple{I}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.Unsafe, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I}, I}} where {N, I&lt;:Integer}"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.degree_from_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">degree_from_index(unsafe, ::AbstractExponents{N,I}, index::I)</code></pre><p>Unsafe variant of <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.MultivariateExponents.degree_from_index-Union{Tuple{I}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I}, I}} where {N, I&lt;:Integer}"><code>degree_from_index</code></a>: assumes that the required cache for the degree that is associated with <code>index</code> has already been initialized, else the behavior is undefined (and in fact, non-deterministic, as it depends on the current size of the cache).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L162-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.convert_index-Union{Tuple{IS}, Tuple{I}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.Unsafe, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, IS}, IS, Int64}} where {N, I&lt;:Integer, IS&lt;:Integer}" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.convert_index-Union{Tuple{IS}, Tuple{I}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.Unsafe, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, IS}, IS, Int64}} where {N, I&lt;:Integer, IS&lt;:Integer}"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.convert_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_index(unsafe, target::AbstractExponents{N}, source::AbstractExponents{N,I},
    index::I[, degree::Int])</code></pre><p>Unsafe variant of <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.MultivariateExponents.convert_index-Union{Tuple{IS}, Tuple{I}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, IS}, IS, Int64}} where {N, I&lt;:Integer, IS&lt;:Integer}"><code>convert_index</code></a>: assumes that caches for both the source and the target are set up as required for <code>degree</code>. If <code>degree</code> is omitted, it is calculated using the unsafe variant of <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.MultivariateExponents.degree_from_index-Union{Tuple{I}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.Unsafe, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I}, I}} where {N, I&lt;:Integer}"><code>degree_from_index</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L180-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.compare_indices-Union{Tuple{I2}, Tuple{I1}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.Unsafe, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I1}, I1, Union{typeof(!=), typeof(&lt;), typeof(&lt;=), typeof(==), typeof(&gt;), typeof(&gt;=)}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I2}, I2, Int64}} where {N, I1&lt;:Integer, I2&lt;:Integer}" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.compare_indices-Union{Tuple{I2}, Tuple{I1}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.Unsafe, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I1}, I1, Union{typeof(!=), typeof(&lt;), typeof(&lt;=), typeof(==), typeof(&gt;), typeof(&gt;=)}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I2}, I2, Int64}} where {N, I1&lt;:Integer, I2&lt;:Integer}"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.compare_indices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compare_indices(unsafe, e₁::AbstractExponents, index₁, op, e₂::AbstractExponents,
    index₂[, degree::Int])</code></pre><p>Unsafe variant of <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.MultivariateExponents.compare_indices-Union{Tuple{I2}, Tuple{I1}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I1}, I1, Union{typeof(!=), typeof(&lt;), typeof(&lt;=), typeof(==), typeof(&gt;), typeof(&gt;=)}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I2}, I2, Int64}} where {N, I1&lt;:Integer, I2&lt;:Integer}"><code>compare_indices</code></a>: assumes that both caches are set up as required for <code>degree</code> (which, if given, must be the common degree of both exponents). If <code>degree</code> is omitted, it is calculated using the unsafe variant of <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.MultivariateExponents.degree_from_index-Union{Tuple{I}, Tuple{N}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.Unsafe, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I}, I}} where {N, I&lt;:Integer}"><code>degree_from_index</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponents.jl#L266-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.Unsafe, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponentsDegreeBounded}" href="#Base.length-Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.Unsafe, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponentsDegreeBounded}"><code>Base.length</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">length(unsafe, e::AbstractExponentsDegreeBounded)</code></pre><p>Unsafe variant of <a href="intpolynomials.html#Base.length-Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponentsDegreeBounded}"><code>length</code></a>: requires the cache to be set up correctly, else the behavior is undefined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/exponents/AbstractExponentsDegreeBounded.jl#L16-L21">source</a></section></article><p>Note that the <code>unsafe</code> singleton is not exported on purpose.</p><h2 id="Limitations"><a class="docs-heading-anchor" href="#Limitations">Limitations</a><a id="Limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Limitations" title="Permalink"></a></h2><p>Monomials do not support a lot of operations once they are constructed (hence the &quot;simple&quot;); however, they of course allow to iterate through their exponents, convert the index between different types of exponent sets, can be conjugated (sometimes with zero cost) and can be multiplied with each other. Polynomials can be evaluated at a fully specified point.</p><p>This makes <code>IntPolynomials</code> very specialized for the particular needs of <code>PolynomialOptimization</code>; however, all the functionality is wrapped in its own subpackage and can be loaded independently of the main package. Don&#39;t do the conversion manually and then pass the converted polynomials to <a href="reference.html#PolynomialOptimization.poly_problem-Tuple{P} where P&lt;:AbstractPolynomialLike"><code>poly_problem</code></a> - when the polynomial problem is initialized, depending on the keyword arguments, some operations still need to be carried out using the full interface of <code>MultivariatePolynomials</code>, not just the restricted subset that <code>IntPolynomials</code> provides.</p><p>Handling the exponents without the <code>MultivariatePolynomials</code> machinery is also deferred to subpackage of <code>IntPolynomials</code>, <code>MultivariateExponents</code>. Note that these exponents and their indices always refer to the graded lexicographic order, which is the default in <code>DynamicPolynomials</code>.</p><h2 id="The-MultivariatePolynomials-interface"><a class="docs-heading-anchor" href="#The-MultivariatePolynomials-interface">The MultivariatePolynomials interface</a><a id="The-MultivariatePolynomials-interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-MultivariatePolynomials-interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.IntVariable" href="#PolynomialOptimization.IntPolynomials.IntVariable"><code>PolynomialOptimization.IntPolynomials.IntVariable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntVariable{Nr,Nc,I&lt;:Unsigned} &lt;: AbstractVariable</code></pre><p><code>IntVariable</code> is the basic type for any simple variable in a polynomial right with <code>Nr</code> real and <code>Nc</code> complex-valued variables. The variable is identified by its index of type <code>I</code> alone. A variable can be explicitly cast to <code>I</code> in order to obtain its index.</p><p>To construct a real-valued or complex-valued variable, see <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntRealVariable"><code>IntRealVariable</code></a> and <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntComplexVariable"><code>IntComplexVariable</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Note that <code>I</code> has nothing to do with the index type used to identify monomials or exponents; in fact, <code>I</code> is automatically calculated as the smallest <code>Unsigned</code> descendant that can still hold the value <code>Nr+2Nc</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/Variable.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.IntRealVariable" href="#PolynomialOptimization.IntPolynomials.IntRealVariable"><code>PolynomialOptimization.IntPolynomials.IntRealVariable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntRealVariable{Nr,Nc}(index::Integer)</code></pre><p>Creates a new real-valued simple variable whose identity is determined by <code>index</code>. Real-valued variables with the same index are considered identical; however, they are different from complex-valued variables constructed with the same index. A real variable will print as <code>xᵢ</code>, where the subscript is given by <code>index</code>. The variable is part of the polynomial ring with <code>Nr</code> real and <code>Nc</code> complex variables.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This method is for construction of the variable only. Do not use it in type comparisons; variables constructed with this method will <em>not</em> be of type <code>IntRealVariable</code> (in fact, don&#39;t think of it as a type), but rather of type <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntVariable"><code>IntVariable</code></a>!</p></div></div><p>See also <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntVariable"><code>IntVariable</code></a>, <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntComplexVariable"><code>IntComplexVariable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/Variable.jl#L32-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.IntComplexVariable" href="#PolynomialOptimization.IntPolynomials.IntComplexVariable"><code>PolynomialOptimization.IntPolynomials.IntComplexVariable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntComplexVariable{Nr,Nc}(index::Integer, isconj::Bool=false)</code></pre><p>Creates a new complex-valued simple variable whose identity is determined by <code>index</code>, and which is a conjugate variable if <code>isconj</code> is set appropriately. Complex-valued variables with the same index and <code>isconj</code> state are considered identical; however, they are different from real-valued variables constructed with the same index, even if they are not conjugate. A complex variable will print as <code>zᵢ</code> (if <code>isconj=false</code>) or <code>z̄ᵢ</code> (if <code>isconj=true</code>), where the subscript is given by <code>index</code>. The variable is part of the polynomial ring with <code>Nr</code> real and <code>Nc</code> complex variables.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This method is for construction of the variable only. Do not use it in type comparisons; variables constructed with this method will <em>not</em> be of type <code>IntComplexVariable</code> (in fact, don&#39;t think of it as a type), but rather of type <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntVariable"><code>IntVariable</code></a>!</p></div></div><p>See also <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntVariable"><code>IntVariable</code></a>, <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntRealVariable"><code>IntRealVariable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/Variable.jl#L54-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.IntMonomial" href="#PolynomialOptimization.IntPolynomials.IntMonomial"><code>PolynomialOptimization.IntPolynomials.IntMonomial</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntMonomial{Nr,Nc,I&lt;:Integer,E&lt;:AbstractExponents} &lt;: AbstractMonomial</code></pre><p><code>IntMonomial</code> represents a monomial. In order to be used together in operations, the number of real-valued variables <code>Nr</code> and the number of complex-valued variables <code>Nc</code> are fixed in the type. The monomial is identified according to its index (of type <code>I</code>) in an exponent set of type <code>E</code>. This should be an unsigned type, but to allow for <code>BigInt</code>, no such restriction is imposed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/Monomial.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.IntMonomial-Union{Tuple{Nc}, Tuple{Nr}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents, Vararg{AbstractVector{&lt;:Integer}}}} where {Nr, Nc}" href="#PolynomialOptimization.IntPolynomials.IntMonomial-Union{Tuple{Nc}, Tuple{Nr}, Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents, Vararg{AbstractVector{&lt;:Integer}}}} where {Nr, Nc}"><code>PolynomialOptimization.IntPolynomials.IntMonomial</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntMonomial{Nr,0[,I]}([e::AbstractExponents,]
    exponents_real::AbstractVector{&lt;:Integer})
IntMonomial{0,Nc[,I]}([e::AbstractExponents,]
    exponents_complex::AbstractVector{&lt;:Integer},
    exponents_conj::AbstractVector{&lt;:Integer})
IntMonomial{Nr,Nc[,I]}([e::AbstractExponents,]
    exponents_real::AbstractVector{&lt;:Integer},
    exponents_complex::AbstractVector{&lt;:Integer},
    exponents_conj::AbstractVector{&lt;:Integer})</code></pre><p>Creates a monomial within an exponent set <code>e</code>. If <code>e</code> is omitted, <code>ExponentsAll{Nr+2Nc,UInt}</code> is chosen by default. Alternatively, all three methods may also be called with the index type <code>I</code> as a third type parameter, omitting <code>e</code>, which then chooses <code>ExponentsAll{Nr+2Nc,I}</code> by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/Monomial.jl#L27-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.IntConjMonomial" href="#PolynomialOptimization.IntPolynomials.IntConjMonomial"><code>PolynomialOptimization.IntPolynomials.IntConjMonomial</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntConjMonomial(m::IntMonomial) &lt;: AbstractMonomial</code></pre><p>This is a wrapper type for the conjugate of a simple monomial. A lot of operations allow to pass either <code>IntConjMonomial</code> or <code>IntMonomial</code>. Constructing the conjugate using this type works in zero time.</p><p>See also <a href="intpolynomials.html#Base.conj-Tuple{Union{PolynomialOptimization.IntPolynomials.IntConjMonomial{Nr, Nc, I, E}, PolynomialOptimization.IntPolynomials.IntMonomial{Nr, Nc, I, E}} where {Nr, Nc, I&lt;:Integer, E&lt;:PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents}}"><code>conj</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/Monomial.jl#L137-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.IntMonomial-Union{Tuple{PolynomialOptimization.IntPolynomials.IntConjMonomial{Nr, Nc}}, Tuple{Nc}, Tuple{Nr}} where {Nr, Nc}" href="#PolynomialOptimization.IntPolynomials.IntMonomial-Union{Tuple{PolynomialOptimization.IntPolynomials.IntConjMonomial{Nr, Nc}}, Tuple{Nc}, Tuple{Nr}} where {Nr, Nc}"><code>PolynomialOptimization.IntPolynomials.IntMonomial</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntMonomial(c::IntConjMonomial)</code></pre><p>Converts a <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntConjMonomial"><code>IntConjMonomial</code></a> into a <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntMonomial"><code>IntMonomial</code></a>. This performs the calculation of the conjugate index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/Monomial.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.IntMonomialVector" href="#PolynomialOptimization.IntPolynomials.IntMonomialVector"><code>PolynomialOptimization.IntPolynomials.IntMonomialVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntMonomialVector{Nr,0[,I]}([e::AbstractExponents,]
    exponents_real::AbstractMatrix{&lt;:Integer}, along...)
IntMonomialVector{0,Nc[,I]}([e::AbstractExponents,]
    exponents_complex::AbstractMatrix{&lt;:Integer},
    exponents_conj::AbstractMatrix{&lt;:Integer}, along...)
IntMonomialVector{Nr,Nc[,I]}([e::AbstractExponents,]
    exponents_real::AbstractMatrix{&lt;:Integer},
    exponents_complex::AbstractMatrix{&lt;:Integer},
    exponents_conj::AbstractMatrix{&lt;:Integer}, along...)</code></pre><p>Creates a monomial vector, where each column corresponds to one monomial and each row contains its exponents. The internal representation will be made with respect to the exponent set <code>e</code>. If <code>e</code> is omitted, <code>ExponentsAll{Nr+2Nc,UInt}</code> is chosen by default. Alternatively, all three methods may also be called with the index type <code>I</code> as a third type parameter, omitting <code>e</code>, which then chooses <code>ExponentsAll{Nr+2Nc,I}</code> by default. All matrices must have the same number of columns; complex and conjugate matrices must have the same number of rows. The input will be sorted; if <code>along</code> are present, those vectors will be put in the same order as the inputs. The input must not contain duplicates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/MonomialVector.jl#L35-L53">source</a></section><section><div><pre><code class="language-julia hljs">IntMonomialVector[{I}](mv::AbstractVector{&lt;:AbstractMonomialLike}, along...;
    vars=variables(mv))</code></pre><p>Creates a <code>IntMonomialVector</code> from a generic monomial vector that supports <code>MultivariatePolynomials</code>&#39;s interface. The monomials will internally be represented by the type <code>I</code> (<code>UInt</code> by default). The keyword argument <code>vars</code> must contain all real-valued and original complex-valued (so not the conjugates) variables that occur in the monomial vector. However, the order of this iterable (which must have a length) controls how the MP variables are mapped to <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntVariable"><code>IntVariable</code></a>s. The variables must be commutative; there is currently no way to check for this, so in the conversion process, commutativity is simply assumed. The input must not contain duplicates. It will be sorted; if <code>along</code> are present, those vectors will be put in the same order as the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/MonomialVector.jl#L124-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.IntPolynomial" href="#PolynomialOptimization.IntPolynomials.IntPolynomial"><code>PolynomialOptimization.IntPolynomials.IntPolynomial</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntPolynomial[{I}](p::AbstractPolynomialLike{C}, coefficient_type=C; kwargs...) where {C}</code></pre><p>Creates a new <code>IntPolynomial</code> based on any polynomial-like object that implements <code>MultivariatePolynomials</code>&#39;s <code>AbstractPolynomialLike</code> interface. The coefficients will be of type <code>coefficient_type</code>, the internal index type for the monomials will be <code>I</code> (<code>UInt</code> if omitted). Keyword arguments are passed on to <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntMonomialVector"><code>IntMonomialVector</code></a>, which allows to influence the variable mapping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/Polynomial.jl#L135-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.change_backend" href="#PolynomialOptimization.IntPolynomials.change_backend"><code>PolynomialOptimization.IntPolynomials.change_backend</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">change_backend(mv::IntMonomialVector, variable::AbstractVector{&lt;:AbstractVariable})</code></pre><p>Changes a <code>IntMonomialVector</code> into a different implementation of <code>MultivariatePolynomials</code>, where the variables are taken from the given vector in the order as they appear (but keeping real and complex variables distinct).</p><p>This conversion is not particularly efficient, as it works with generic implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/MonomialVector.jl#L1337-L1344">source</a></section><section><div><pre><code class="language-julia hljs">change_backend(p::IntPolynomial, variables::AbstractVector{&lt;:AbstractVariable})</code></pre><p>Changes a <code>IntPolynomial</code> into a different implementation of <code>MultivariatePolynomials</code>, where the variables are taken from the given vector in the order as they appear (but keeping real and complex variables distinct). Note that the coefficients are returned without making a copy, which depending on the backend can imply back-effects on <code>p</code> itself should the output be changed. This conversion is not particularly efficient, as it works with generic implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/Polynomial.jl#L257-L265">source</a></section></article><h2 id="Implementation-peculiarities"><a class="docs-heading-anchor" href="#Implementation-peculiarities">Implementation peculiarities</a><a id="Implementation-peculiarities-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-peculiarities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.conj-Tuple{Union{PolynomialOptimization.IntPolynomials.IntConjMonomial{Nr, Nc, I, E}, PolynomialOptimization.IntPolynomials.IntMonomial{Nr, Nc, I, E}} where {Nr, Nc, I&lt;:Integer, E&lt;:PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents}}" href="#Base.conj-Tuple{Union{PolynomialOptimization.IntPolynomials.IntConjMonomial{Nr, Nc, I, E}, PolynomialOptimization.IntPolynomials.IntMonomial{Nr, Nc, I, E}} where {Nr, Nc, I&lt;:Integer, E&lt;:PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents}}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conj(m::Union{&lt;:IntMonomial,&lt;:IntConjMonomial})</code></pre><p>Creates the conjugate of a <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntMonomial"><code>IntMonomial</code></a>. The result type of this operation will always be <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntMonomial"><code>IntMonomial</code></a>. If the conjugate can be used to work with lazily, consider wrapping the monomial in a <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntConjMonomial"><code>IntConjMonomial</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/Monomial.jl#L383-L388">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.variable_index" href="#PolynomialOptimization.IntPolynomials.variable_index"><code>PolynomialOptimization.IntPolynomials.variable_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">variable_index(v::IntVariable{Nr,Nc})</code></pre><p>Returns the index of the variable <code>v</code>, where real-valued variables have indices between 1 and <code>Nr</code>, and complex-valued variables have indices between <code>Nr+1</code> and <code>Nr+Nc</code>. Conjugates have the same indices as their ordinary variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/Variable.jl#L164-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.monomial_product" href="#PolynomialOptimization.IntPolynomials.monomial_product"><code>PolynomialOptimization.IntPolynomials.monomial_product</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">monomial_product(e::AbstractExponents, m...)</code></pre><p>Calculates the product of all monomials (or conjugates, or variables) <code>m</code>. The result must be part of the exponent set <code>e</code>. If the default multiplication <code>*</code> is used instead, <code>e</code> will always be <code>ExponentsAll</code> with the jointly promoted index type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/Monomial.jl#L419-L424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.monomial_index" href="#PolynomialOptimization.IntPolynomials.monomial_index"><code>PolynomialOptimization.IntPolynomials.monomial_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">monomial_index([e::AbstractExponents,] m...)</code></pre><p>Calculates the index of the given monomial (or the product of all given monomials, or conjugates, or variables) <code>m</code>. The result must be part of the exponent set <code>e</code>. If <code>e</code> is omitted, it will be be <code>ExponentsAll</code> with the jointly promoted index type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/Monomial.jl#L464-L469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.effective_nvariables" href="#PolynomialOptimization.IntPolynomials.effective_nvariables"><code>PolynomialOptimization.IntPolynomials.effective_nvariables</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">effective_nvariables(x::Union{&lt;:IntMonomialVector{Nr,Nc},
                              &lt;:AbstractArray{&lt;:IntMonomialVector{Nr,Nc}}}...)</code></pre><p>Calculates the number of effective variable of its arguments: there are at most <code>Nr + 2Nc</code> variables that may occur in any of the monomial vectors or arrays of monomial vectors in the arguments. This function calculates efficiently the number of variables that actually occur at least once anywhere in any argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/MonomialVector.jl#L671-L678">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.monomials-Union{Tuple{Nc}, Tuple{Nr}, Tuple{Val{Nr}, Val{Nc}, AbstractUnitRange{&lt;:Integer}}} where {Nr, Nc}" href="#MultivariatePolynomials.monomials-Union{Tuple{Nc}, Tuple{Nr}, Tuple{Val{Nr}, Val{Nc}, AbstractUnitRange{&lt;:Integer}}} where {Nr, Nc}"><code>MultivariatePolynomials.monomials</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">monomials(Nr, Nc, degree::AbstractUnitRange{&lt;:Integer};
    minmultideg=nothing, maxmultideg=nothing, filter_exps=nothing,
    filter_mons=nothing, I=UInt)</code></pre><p>Returns a <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.IntMonomialVector"><code>IntMonomialVector</code></a> with <code>Nr</code> real and <code>Nc</code> complex variables, total degrees contained in <code>degree</code>, ordered according to <code>Graded{LexOrder}</code> and individual variable degrees varying between <code>minmultideg</code> and <code>maxmultideg</code> (where real variables come first, then complex variables, then their conjugates).</p><p>The monomial vector will take possession of the min/maxmultidegs, do not modify them afterwards.</p><p>An additional filter may be employed to drop monomials during the construction. Note that the presence of a filter function will change to a less efficient internal representation. The filter function can get a vector with the exponents as its argument (<code>filter_exps</code>) or a filter function that gets the corresponding <code>IntMonomial</code>. The former is more efficient if every exponent has to be retrieved (but do not alter the argument).</p><p>The internal representation will be of the type <code>I</code>.</p><p>This function can be made type-stable by passing <code>Nr</code> and <code>Nc</code> as <code>Val</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/MonomialVector.jl#L738-L757">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.intersect-Union{Tuple{Nc}, Tuple{Nr}, Tuple{PolynomialOptimization.IntPolynomials.IntMonomialVector{Nr, Nc, I, E, T} where {I&lt;:Integer, E, T&lt;:(PolynomialOptimization.IntPolynomials.IntMonomial{Nr, Nc, I})}, PolynomialOptimization.IntPolynomials.IntMonomialVector{Nr, Nc, I, E, T} where {I&lt;:Integer, E, T&lt;:(PolynomialOptimization.IntPolynomials.IntMonomial{Nr, Nc, I})}}} where {Nr, Nc}" href="#Base.intersect-Union{Tuple{Nc}, Tuple{Nr}, Tuple{PolynomialOptimization.IntPolynomials.IntMonomialVector{Nr, Nc, I, E, T} where {I&lt;:Integer, E, T&lt;:(PolynomialOptimization.IntPolynomials.IntMonomial{Nr, Nc, I})}, PolynomialOptimization.IntPolynomials.IntMonomialVector{Nr, Nc, I, E, T} where {I&lt;:Integer, E, T&lt;:(PolynomialOptimization.IntPolynomials.IntMonomial{Nr, Nc, I})}}} where {Nr, Nc}"><code>Base.intersect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intersect(a::IntMonomialVector{Nr,Nc}, b::IntMonomialVector{Nr,Nc})</code></pre><p>Calculates efficiently the intersection of two monomial vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/MonomialVector.jl#L796-L800">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.merge_monomial_vectors-Union{Tuple{I}, Tuple{N}, Tuple{Nc}, Tuple{Nr}, Tuple{Val{Nr}, Val{Nc}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I}, AbstractVector}} where {Nr, Nc, N, I&lt;:Integer}" href="#MultivariatePolynomials.merge_monomial_vectors-Union{Tuple{I}, Tuple{N}, Tuple{Nc}, Tuple{Nr}, Tuple{Val{Nr}, Val{Nc}, PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents{N, I}, AbstractVector}} where {Nr, Nc, N, I&lt;:Integer}"><code>MultivariatePolynomials.merge_monomial_vectors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge_monomial_vectors(::Val{Nr}, ::Val{Nc}, e::AbstractExponents, X::AbstractVector)</code></pre><p>Returns the vector of monomials contained <code>X</code> in increasing order and without any duplicates. The individual elements in <code>X</code> must be sorted iterables with a length and return <code>IntMonomial</code>s compatible with the number of real <code>Nr</code> and complex variables <code>Nc</code>. The output will internally use the exponents <code>e</code>. The result type will be a <code>IntMonomialVector</code> with <code>Nr</code> and <code>Nc</code> as given, <code>I</code> and the exponents determined by <code>e</code>, and indexed internally with a <code>Vector{I}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/MonomialVector.jl#L945-L953">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.merge_monomial_vectors-Tuple{AbstractVector{&lt;:PolynomialOptimization.IntPolynomials.IntMonomialVector}}" href="#MultivariatePolynomials.merge_monomial_vectors-Tuple{AbstractVector{&lt;:PolynomialOptimization.IntPolynomials.IntMonomialVector}}"><code>MultivariatePolynomials.merge_monomial_vectors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge_monomial_vectors(X::AbstractVector)</code></pre><p>Potentially type-unstable variant that automatically determines the output format. If <code>X</code> has a defined eltype with known eltype <code>&lt;:IntMonomial{Nr,Nc,I,E}</code>, <code>Nr</code>, <code>Nc</code>, and <code>I</code> are determined automatically in a type-stable manner. If not, they are taken from the eltype of the first iterable in <code>X</code> (which is not type stable). If this is not possible, either, they are taken from the first element in the first nonempty iterable in <code>X</code>.</p><p>Regarding the automatic determination of <code>E</code>, the following rule is applied: it is assumed that if <code>E</code> is known in the element type, then every monomial will have the same instance of <code>e</code> as the exponents <em>per iterable</em> (this is always satisfied if the iterables are <code>IntMonomialVector</code>s). If there is one exponent that covers all others, this instance will be used. If not, the largest necessary exponents will be constructed; the result will be indexed unless all can be merged contiguously). Note that inhomogeneous iterables must implement <code>last</code> if the elements are based on <code>ExponentsAll</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This method has a very general type signature and may therefore also be called for other implementations of <code>MultivariatePolynomials</code>. However, this case will be caught and then forwarded to the generic MP implementation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/MonomialVector.jl#L998-L1015">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.MultivariateExponents.veciter-Union{Tuple{indexed}, Tuple{PolynomialOptimization.IntPolynomials.IntMonomialVector, AbstractVector{Int64}, Val{indexed}}} where indexed" href="#PolynomialOptimization.IntPolynomials.MultivariateExponents.veciter-Union{Tuple{indexed}, Tuple{PolynomialOptimization.IntPolynomials.IntMonomialVector, AbstractVector{Int64}, Val{indexed}}} where indexed"><code>PolynomialOptimization.IntPolynomials.MultivariateExponents.veciter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">veciter(mv::IntMonomialVector[, v::AbstractVector{Int}], indexed::Bool=false)</code></pre><p>Creates an iterator over all exponents present in <code>mv</code> (see <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.MultivariateExponents.veciter-Tuple{PolynomialOptimization.IntPolynomials.MultivariateExponents.AbstractExponents, AbstractVector{Int64}}"><code>veciter</code></a> for <code>AbstractExponents</code>). By setting <code>indexed</code> to <code>true</code>, this iterator will instead give a tuple similar to <code>enumerate</code>, where the first index corresponds to the index of the monomial in the exponent set (so it does not necessarily start at <code>1</code> or have unit step). For type stability, <code>indexed</code> may instead be <code>Val(false)</code> or <code>Val(true)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/MonomialVector.jl#L323-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.IntPolynomials.keepat!!" href="#PolynomialOptimization.IntPolynomials.keepat!!"><code>PolynomialOptimization.IntPolynomials.keepat!!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">keepat!!(x::IntMonomialVector, i::AbstractVector{Bool})</code></pre><p>Keeps the <code>j</code>ᵗʰ monomial in <code>x</code> only if <code>i[j]</code> is <code>true</code>. This will mutate <code>x</code> if possible (i.e., if it was already indexed by a vector before), but it might also create a new vector if required (i.e., if a whole range of exponents was covered). Always use the return value, never rely on <code>x</code>. This function is not exported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/poly/MonomialVector.jl#L216-L223">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="auxreference.html">« Reference of auxilliaries</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Sunday 30 March 2025 14:49">Sunday 30 March 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
