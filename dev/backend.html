<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Backend · PolynomialOptimization.jl</title><meta name="title" content="Backend · PolynomialOptimization.jl"/><meta property="og:title" content="Backend · PolynomialOptimization.jl"/><meta property="twitter:title" content="Backend · PolynomialOptimization.jl"/><meta name="description" content="Documentation for PolynomialOptimization.jl."/><meta property="og:description" content="Documentation for PolynomialOptimization.jl."/><meta property="twitter:description" content="Documentation for PolynomialOptimization.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">PolynomialOptimization.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="guide.html">Walkthrough</a></li><li><a class="tocitem" href="reference.html">Reference</a></li><li><a class="tocitem" href="includedsolvers.html">Supported solvers</a></li><li class="is-active"><a class="tocitem" href="backend.html">Backend</a><ul class="internal"><li><a class="tocitem" href="#[poly_optimize](@ref)"><span><code>poly_optimize</code></span></a></li><li><a class="tocitem" href="#[Newton.halfpolytope](@ref)"><span><code>Newton.halfpolytope</code></span></a></li><li><a class="tocitem" href="#Automatic-tightening"><span>Automatic tightening</span></a></li></ul></li><li><a class="tocitem" href="auxreference.html">Reference of auxilliaries</a></li><li><a class="tocitem" href="intpolynomials.html">IntPolynomials</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="backend.html">Backend</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="backend.html">Backend</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/projekter/PolynomialOptimization.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/projekter/PolynomialOptimization.jl/blob/main/docs/src/backend.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Backend"><a class="docs-heading-anchor" href="#Backend">Backend</a><a id="Backend-1"></a><a class="docs-heading-anchor-permalink" href="#Backend" title="Permalink"></a></h1><p><code>PolynomialOptimization</code> mostly uses external solvers that have Julia bindings or are implemented in Julia, but it also provides own solver implementations particularly for the purpose of polynomial optimization. This page is only relevant if you intend to implement an interface between <code>PolynomialOptimization</code> and a new solver or if you want to provide missing functionality for an existing solver. It is of no relevance if you only want to use the existing solvers.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The package does not introduce any hard dependencies on the external solvers. Therefore, you may or may not decide to install them on your system. Instead, the solvers are addressed as weak dependencies. This means that <em>you have to load the solver Julia package manually</em> before you are able to use it for optimization.</p></div></div><p><code>PolynomialOptimization</code> also provides an interface that can be implemented if another solver should be supported. This consists of just a few methods for the various functions.</p><div class="admonition is-info"><header class="admonition-header">MathOptInterface</header><div class="admonition-body"><p>Why do we re-invent the wheel and don&#39;t just use <code>MathOptInterface</code>? This would immediately bring compatibility with a huge number of solvers that are available under Julia.</p><p>This would certainly be possible. It might even be a not-too-bad idea to provide an automatic fallback to <code>MathOptInterface</code> in the future for solvers that are not supported natively.</p><p>However, <code>MathOptInterface</code> is enormous in its feature range. Considering that, it is amazingly fast. But in <code>PolynomialOptimization</code>, only a very small subset of all the features is required, and a lot of additional assumptions on how the problem is constructed can be made. This allows to use the solver&#39;s API in a most efficient way, which typically is not the way in which implementations of <code>MathOptInterface</code> would address the solver.</p><p>Additionally, in some situations, a lot of very similar sub-problems need to be solved; in these cases, <code>PolynomialOptimization</code>&#39;s own interface allows to keep the optimizer task alive and just do the tiny modification instead of setting things up from the start again - which for <code>MathOptInterface</code> only works if a solver is implemented in a particular way.</p><p>This focus on efficiency is very important as (relevant) polynomial optimization problems are huge. It is just not possible to waste time and memory in bookkeeping that is not really needed.</p></div></div><h2 id="[poly_optimize](@ref)"><a class="docs-heading-anchor" href="#[poly_optimize](@ref)"><a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a></a><a id="[poly_optimize](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[poly_optimize](@ref)" title="Permalink"></a></h2><p>The optimization of polynomial problems requires a solver that understands linear and semidefinite constraints. All functions in this section are defined (and exported) in the submodule <code>PolynomialOptimization.Solver</code>.</p><h3 id="Solver-interface"><a class="docs-heading-anchor" href="#Solver-interface">Solver interface</a><a id="Solver-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-interface" title="Permalink"></a></h3><p>In general, a solver implementation can do whatever it wants; it just needs to implement the <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a> method with the appropriate <code>Val</code>-wrapped solver method as its first parameter. However, it is very helpful to just do some basic setup such as creating the solver object in this function and delegate all the work of setting up the actual problem to <a href="backend.html#PolynomialOptimization.Solver.moment_setup!"><code>moment_setup!</code></a> or <a href="backend.html#PolynomialOptimization.Solver.sos_setup!"><code>sos_setup!</code></a>. In order to do so, a solver implementation should create a new type that contains all the relevant data during setup of the problem. Usually, a solver falls in one of three categories:</p><ul><li>Problem data has to be supplied in matrix/vector form; in this case, the new type should be a descendant of <a href="backend.html#PolynomialOptimization.Solver.AbstractSparseMatrixSolver"><code>AbstractSparseMatrixSolver</code></a>. Usually, open-source solvers fall in this category.</li><li>Problem data is constructed incrementally via various calls to API functions of the solver, which does not provide access to its internals. In this case, the new type should be a descendant of <a href="backend.html#PolynomialOptimization.Solver.AbstractAPISolver"><code>AbstractAPISolver</code></a>. Usually, commercial solvers fall in this category.</li></ul><p>However, it is not required that the type is in fact a subtype of either of those; the most general possible supertype is <a href="backend.html#PolynomialOptimization.Solver.AbstractSolver"><code>AbstractSolver</code></a>, which does not make any assumptions or provide any but the most skeleton fallback implementations and a default for <a href="backend.html#PolynomialOptimization.Solver.mindex"><code>mindex</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.AbstractSolver" href="#PolynomialOptimization.Solver.AbstractSolver"><code>PolynomialOptimization.Solver.AbstractSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSolver{T,V&lt;:Real}</code></pre><p>Abstract supertype for any solver state. <code>T</code> is the type that is returned by calling <a href="backend.html#PolynomialOptimization.Solver.mindex"><code>mindex</code></a> with such a state; <code>V</code> is the type of the coefficients used in the solver. Using the default implementation for <a href="backend.html#PolynomialOptimization.Solver.mindex"><code>mindex</code></a>, <code>T</code> will be <code>UInt</code>. Most likely, <code>V</code> will be <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Interface.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.mindex" href="#PolynomialOptimization.Solver.mindex"><code>PolynomialOptimization.Solver.mindex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mindex(::AbstractSolver{T}, monomials::IntMonomialOrConj...)::T</code></pre><p>Calculates the index that the product of all monomials will have in the SDP represented by <code>state</code>. The default implementation calculates the one-based monomial index according to a dense deglex order and returns an <code>UInt</code>. The returned index is arbitrary as long as it is unique for the total monomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Interface.jl#L12-L18">source</a></section></article><p>Every implementation of <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a> should return a tuple that contains some internal state of the solver as well as the optimal value and the status of the solver. A method for <a href="backend.html#LinearAlgebra.issuccess-Tuple{Val, Any}-backend"><code>issuccess</code></a> should then translate this status into a simple boolean, where deciding on ambiguities (near success) is up to the solver implementation.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend" href="#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>PolynomialOptimization.Solver.poly_optimize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poly_optimize(::Val{method}, relaxation::AbstractRelaxation,
    groupings::RelaxationGroupings; representation, verbose, kwargs...)</code></pre><p>This is the central entry point that a solver has to implement. It has to carry out the optimization and must return a tuple of three values:</p><ol><li>An internal state that can be used later on to access the solver again to extract solutions or (if possible) reoptimization.</li><li>The success status as returned by the solver and understood by the <a href="backend.html#LinearAlgebra.issuccess-Tuple{Val, Any}-backend"><code>issuccess</code></a> implementation.</li><li>The minimum value of the objective.</li></ol><p>See also <a href="backend.html#PolynomialOptimization.Solver.moment_setup!"><code>moment_setup!</code></a>, <a href="backend.html#PolynomialOptimization.Solver.sos_setup!"><code>sos_setup!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Solver.jl#L44-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.issuccess-Tuple{Val, Any}-backend" href="#LinearAlgebra.issuccess-Tuple{Val, Any}-backend"><code>LinearAlgebra.issuccess</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">issuccess(::Val{method}, status)</code></pre><p>A solver must implement this method for all of its possible methods to indicate whether a status <code>status</code> signifies success.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Solver.jl#L59-L63">source</a></section></article><p>Once a solver has been implemented, it should add its solver symbol to the vector <code>solver_methods</code>, which enables this solver to be chosen automatically. Apart from the exact specification <code>:&lt;solvername&gt;Moment</code> or <code>:&lt;solvername&gt;SOS</code>, a short form <code>:&lt;solvername&gt;</code> that chooses the recommended method should also be implemented. For this, the <a href="backend.html#PolynomialOptimization.Solver.@solver_alias"><code>@solver_alias</code></a> macro can be used. When details on the solution data a requested, the <a href="backend.html#PolynomialOptimization.Solver.extract_moments"><code>extract_moments</code></a>, <a href="backend.html#PolynomialOptimization.Solver.extract_sos"><code>extract_sos</code></a>, or <a href="backend.html#PolynomialOptimization.Solver.extract_info"><code>extract_info</code></a> function is called, where at least the former two have to be implemented for each solver:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.extract_moments" href="#PolynomialOptimization.Solver.extract_moments"><code>PolynomialOptimization.Solver.extract_moments</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_moments(relaxation::AbstractRelaxation, state)</code></pre><p>Extracts a <a href="reference.html#PolynomialOptimization.MomentVector"><code>MomentVector</code></a> from a solved relaxation. The <code>state</code> parameter is the first return value of the <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a> call by the solver. This function is only called once for each result; the output is cached.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Extraction.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.extract_sos" href="#PolynomialOptimization.Solver.extract_sos"><code>PolynomialOptimization.Solver.extract_sos</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_sos(relaxation::AbstractRelaxation, state, ::Val{type},
    index::Union{&lt;:Integer,&lt;:AbstractUnitRange}, rawstate) where {type}</code></pre><p>Extracts data that contains the raw solver information about the SOS data contained in the result. For moment optimizations, this corresponds to the dual data; for SOS optimizations, this is the primal data. <code>rawstate</code> is the return value of the preceding call to <a href="backend.html#PolynomialOptimization.Solver.extract_sos_prepare"><code>extract_sos_prepare</code></a> (by default, <code>nothing</code>). Note that the SOS data may be queried in any order, partially or completely.</p><p>The parameters <code>type</code> and <code>index</code> indicates which constraint/variable the data corresponds to. <code>type</code> is a symbol, <code>index</code> is the range of indices within constraints of the same type, although both the type as well as the interpretation of <code>index</code> may change by providing custom definitions for <a href="backend.html#PolynomialOptimization.Solver.addtocounter!"><code>addtocounter!</code></a> or using the macros <a href="backend.html#PolynomialOptimization.Solver.@counter_atomic"><code>@counter_atomic</code></a> and <a href="backend.html#PolynomialOptimization.Solver.@counter_alias"><code>@counter_alias</code></a>.</p><p>The return value of this function should be a scalar, vector, or matrix, depending on what data was requested. The following relations should hold:</p><table><tr><th style="text-align: right"><code>type</code></th><th style="text-align: left">result type</th></tr><tr><td style="text-align: right"><code>:fix</code> (moment only)</td><td style="text-align: left">vector</td></tr><tr><td style="text-align: right"><code>:free</code> (SOS only)</td><td style="text-align: left">vector</td></tr><tr><td style="text-align: right"><code>:nonnegative</code></td><td style="text-align: left">vector</td></tr><tr><td style="text-align: right"><code>:quadratic</code></td><td style="text-align: left">vector</td></tr><tr><td style="text-align: right"><code>:rotated_quadratic</code></td><td style="text-align: left">vector</td></tr><tr><td style="text-align: right"><code>:psd</code></td><td style="text-align: left">vector<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> or matrix</td></tr><tr><td style="text-align: right"><code>:psd_complex</code></td><td style="text-align: left">vector<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup><sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> or matrix</td></tr><tr><td style="text-align: right"><code>:dd</code></td><td style="text-align: left">vector<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> or matrix</td></tr><tr><td style="text-align: right"><code>:dd_complex</code></td><td style="text-align: left">vector<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup><sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> or matrix</td></tr><tr><td style="text-align: right"><code>:lnorm</code></td><td style="text-align: left">vector</td></tr><tr><td style="text-align: right"><code>:lnorm_complex</code></td><td style="text-align: left">vector<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></td></tr><tr><td style="text-align: right"><code>:sdd</code></td><td style="text-align: left">vector</td></tr><tr><td style="text-align: right"><code>:sdd_complex</code></td><td style="text-align: left">vector<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></td></tr></table><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It is guaranteed that the range that is queries using <code>index</code> always corresponds to data that was added contiguously, with no other cones interspersed.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Extraction.jl#L37-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.extract_sos_prepare" href="#PolynomialOptimization.Solver.extract_sos_prepare"><code>PolynomialOptimization.Solver.extract_sos_prepare</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_sos_prepare(relaxation::AbstractRelaxation, state)</code></pre><p>Prepares for one or multiple calls of <a href="backend.html#PolynomialOptimization.Solver.extract_sos"><code>extract_sos</code></a>. The return value will be passed to the function as an argument. This is particularly relevant for solvers which don&#39;t allow the extraction of subsets of the data, but only the whole vector: Retrieve it here, then pass it as an output. The default implementation does nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Extraction.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.extract_info" href="#PolynomialOptimization.Solver.extract_info"><code>PolynomialOptimization.Solver.extract_info</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_info(state)</code></pre><p>Returns the internal information on the problem that was given back by <a href="backend.html#PolynomialOptimization.Solver.moment_setup!"><code>moment_setup!</code></a> or <a href="backend.html#PolynomialOptimization.Solver.sos_setup!"><code>sos_setup!</code></a>. There is a default implementation that returns the value of the property <code>info</code> on <code>state</code> (which also works if the original state is wrapped as the first element of a tuple).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Extraction.jl#L13-L19">source</a></section></article><p>In order to relate aspects of the problem with data in the solver, the cones that are added are counted. This works automatically, keeping a separate counter for every type of cone and counting vector-valued cones (which are most) with their actual length. This behavior can be customized:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.@counter_alias" href="#PolynomialOptimization.Solver.@counter_alias"><code>PolynomialOptimization.Solver.@counter_alias</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@counter_alias(::Type{&lt;:AbstractSolver}, counter, alias)</code></pre><p>Defines the <a href="backend.html#PolynomialOptimization.Solver.addtocounter!"><code>addtocounter!</code></a> function in such a way that contraints of type <code>counter</code> instead only affect the counter <code>alias</code>. Do not use <a href="backend.html#PolynomialOptimization.Solver.@counter_atomic"><code>@counter_atomic</code></a> together with this macro on the same <code>counter</code>.</p><p><code>counter</code> may either be a Symbol, a tuple of Symbols, or the value <code>Any</code>. Note that <code>Any</code> has weakest precendence, irrespective of when the macro was called.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Regardless of whether <code>counter</code> or <code>alias</code> where made atomic before, after this macro, <code>counter</code> will not be so (although it shares the same counter as <code>alias</code>). This may or may not be desirable (most likely not), so always make atomic counters explicit using <a href="backend.html#PolynomialOptimization.Solver.@counter_atomic"><code>@counter_atomic</code></a>, which allows the definition of aliases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Counters.jl#L91-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.@counter_atomic" href="#PolynomialOptimization.Solver.@counter_atomic"><code>PolynomialOptimization.Solver.@counter_atomic</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@counter_atomic(::Type{&lt;:AbstractSolver}, counter[, alias])</code></pre><p>Defines the <a href="backend.html#PolynomialOptimization.Solver.addtocounter!"><code>addtocounter!</code></a> function in such a way that a multi-dimensional constraint of type <code>counter</code> is always counted as a single entry. This macro may be called at most once for each counter when defining a solver. As a consequence, <a href="backend.html#PolynomialOptimization.Solver.extract_sos"><code>extract_sos</code></a> will may have an <code>Int</code> or a <code>UnitRange{Int}</code> (if multiple constraints are required, which will never be the case for matrix cones) as <code>index</code> parameter for the <code>counter</code> type.</p><p>If the <code>alias</code> parameter is present, whenever the type <code>counter</code> is encountered, the counter of type <code>alias</code> is incremented instead. Do not use <a href="backend.html#PolynomialOptimization.Solver.@counter_alias"><code>@counter_alias</code></a> together with this macro on the same <code>counter</code>.</p><p><code>counter</code> may either be a Symbol, a tuple of Symbols, or the value <code>Any</code>. Note that <code>Any</code> has weakest precedence, irrespective of when the macro is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Counters.jl#L64-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.addtocounter!" href="#PolynomialOptimization.Solver.addtocounter!"><code>PolynomialOptimization.Solver.addtocounter!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addtocounter!(state, counters::Counters, ::Val{type}, dim::Integer) where {type} -&gt; Int
addtocounter!(state, counters::Counters, ::Val{type}, num::Integer,
    dim::Integer) where {type} -&gt; UnitRange{Int}</code></pre><p>Increments the internal information about how many constraints/variables of a certain type were already added. Usually, a solver implementation does not have to overwrite the default implementation; but it might be useful to do so if some types are for example counted in a single counter or bunch of added elements counts as a single entry. <code>dim</code> is the length of the conic constraint or variable, while <code>num</code> indicates that multiple such constraints or variables of the same type are added. For a list of possible symbols <code>type</code>, see the documentation for <a href="backend.html#PolynomialOptimization.Solver.extract_sos"><code>extract_sos</code></a>.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.Counters"><code>Counters</code></a>, <a href="backend.html#PolynomialOptimization.Solver.@counter_alias"><code>@counter_alias</code></a>, <a href="backend.html#PolynomialOptimization.Solver.@counter_atomic"><code>@counter_atomic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Counters.jl#L26-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.Counters" href="#PolynomialOptimization.Solver.Counters"><code>PolynomialOptimization.Solver.Counters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Counters</code></pre><p>Mutable struct that keeps track of the number of conic constraints/variables currently in use. Every possible symbol listed in the documentation for <a href="backend.html#PolynomialOptimization.Solver.extract_sos"><code>extract_sos</code></a> has an <code>Int</code> field of the same name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Counters.jl#L3-L8">source</a></section></article><p>Using this information, an additional implementation may be provided for a faster re-optimization of the same problem:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.poly_optimize-Tuple{Val, Any, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}" href="#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, Any, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}"><code>PolynomialOptimization.Solver.poly_optimize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poly_optimize(::Val{method}, oldstate, relaxation::AbstractRelaxation,
    groupings::RelaxationGroupings; representation, verbose, kwargs)</code></pre><p>A solver that supports re-optimization of an already optimized problem with changed rotations on the DD and SDD representations should implement this method. It is guaranteed that only the rotations change, and only in a structure-preserving way (diagonal and nondiagonal rotations will not interchange). The return value is as documented in <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a>, and the <code>oldstate</code> parameter holds the first return value of the previous call to <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Solver.jl#L70-L78">source</a></section></article><p>While this page documents in detail how a new solver can be implemented, the explanation is far more extensive than an actual implementation. In order to implement a new solver, it is therefore recommended to first determine the category in which it falls, then copy and modify an appropriate existing implementation.</p><h4 id="[AbstractSparseMatrixSolver](@ref)"><a class="docs-heading-anchor" href="#[AbstractSparseMatrixSolver](@ref)"><a href="backend.html#PolynomialOptimization.Solver.AbstractSparseMatrixSolver"><code>AbstractSparseMatrixSolver</code></a></a><a id="[AbstractSparseMatrixSolver](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[AbstractSparseMatrixSolver](@ref)" title="Permalink"></a></h4><p>This solver type accumulates data in a COO matrix-like format. The callback functions can use <a href="backend.html#Base.append!-Union{Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{I}, Tuple{PolynomialOptimization.Solver.SparseMatrixCOO{I, K, V, Offset}, PolynomialOptimization.Solver.IndvalsIterator{K, V, L, VT, VV} where {L, VT&lt;:AbstractVector{K}, VV&lt;:AbstractVector{V}}}} where {I&lt;:Integer, K&lt;:Integer, V&lt;:Real, Offset}"><code>append!</code></a> to quickly add given data to the temporary storage. However, the format is not yet suitable for passing data to the solver, as all monomials are densely indexed. Therefore, in a postprocessing step, the COO matrices have to be converted to CSC matrices with continuous monomial indices using <a href="backend.html#PolynomialOptimization.Solver.coo_to_csc!-Union{Tuple{Vararg{Union{Tuple{AbstractVector{K}, AbstractVector{V}}, PolynomialOptimization.Solver.SparseMatrixCOO{I, K, V, Offset}}}}, Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{I}} where {I&lt;:Integer, K&lt;:Integer, V&lt;:Real, Offset}"><code>coo_to_csc!</code></a>. After the optimization is done, the optimal moment vector (the decision variables for moment optimization, the constraint duals for SOS optimization) can be constructed using <a href="backend.html#PolynomialOptimization.MomentVector-Union{Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{Nc}, Tuple{Nr}, Tuple{PolynomialOptimization.Relaxation.AbstractRelaxation{&lt;:PolynomialOptimization.Problem{&lt;:PolynomialOptimization.IntPolynomials.IntPolynomial{var&quot;#s3&quot;, Nr, Nc, M} where {var&quot;#s3&quot;, M&lt;:(PolynomialOptimization.IntPolynomials.IntMonomialVector{Nr, Nc, I, E, T} where {I&lt;:Integer, E, T&lt;:(PolynomialOptimization.IntPolynomials.IntMonomial{Nr, Nc, I})})}}}, Vector{V}, K, PolynomialOptimization.Solver.SparseMatrixCOO{&lt;:Integer, K, V, Offset}, Vararg{PolynomialOptimization.Solver.SparseMatrixCOO{&lt;:Integer, K, V, Offset}}}} where {Nr, Nc, K&lt;:Integer, V&lt;:Real, Offset}"><code>MomentVector</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.AbstractSparseMatrixSolver" href="#PolynomialOptimization.Solver.AbstractSparseMatrixSolver"><code>PolynomialOptimization.Solver.AbstractSparseMatrixSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSparseMatrixSolver{I&lt;:Integer,K&lt;:Integer,V&lt;:Real}</code></pre><p>Superclass for a solver that requires its data in sparse matrix form. The data is aggregated in COO form using <a href="backend.html#Base.append!-Union{Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{I}, Tuple{PolynomialOptimization.Solver.SparseMatrixCOO{I, K, V, Offset}, PolynomialOptimization.Solver.IndvalsIterator{K, V, L, VT, VV} where {L, VT&lt;:AbstractVector{K}, VV&lt;:AbstractVector{V}}}} where {I&lt;:Integer, K&lt;:Integer, V&lt;:Real, Offset}"><code>append!</code></a> and can be converted to CSC form using <a href="backend.html#PolynomialOptimization.Solver.coo_to_csc!-Union{Tuple{Vararg{Union{Tuple{AbstractVector{K}, AbstractVector{V}}, PolynomialOptimization.Solver.SparseMatrixCOO{I, K, V, Offset}}}}, Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{I}} where {I&lt;:Integer, K&lt;:Integer, V&lt;:Real, Offset}"><code>coo_to_csc!</code></a>. The type of the indices in final CSC form is <code>I</code>, where the monomials during construction will be represented by numbers of type <code>K</code>. Any type inheriting from this class is supposed to have a field <code>slack::K</code> which is initialized to <code>-one(K)</code> if <code>K</code> is signed or <code>typemax(K)</code> if it is unsigned.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.SparseMatrixCOO"><code>SparseMatrixCOO</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/AbstractSparseMatrixSolver.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.SparseMatrixCOO" href="#PolynomialOptimization.Solver.SparseMatrixCOO"><code>PolynomialOptimization.Solver.SparseMatrixCOO</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SparseMatrixCOO{I&lt;:Integer,K&lt;:Integer,V&lt;:Real,Offset}</code></pre><p>Representation of a sparse matrix in COO form. Fields are <code>rowinds::FastVec{I}</code>, <code>moninds::FastVec{K}</code> (where <code>K</code> is of the type returned by <code>monomial_index</code>), and <code>nzvals::FastVec{V}</code>. The first row/column for the solver has index <code>Offset</code> (of type <code>I</code>).</p><p>If this matrix is used in the context of a vectorized COO matrix, the fields are <code>rows</code>, <code>cols</code>, and <code>vals</code> with <code>K === I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Helpers.jl#L214-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.append!-Union{Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{I}, Tuple{PolynomialOptimization.Solver.SparseMatrixCOO{I, K, V, Offset}, PolynomialOptimization.Solver.Indvals{K, V}}} where {I&lt;:Integer, K&lt;:Integer, V&lt;:Real, Offset}" href="#Base.append!-Union{Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{I}, Tuple{PolynomialOptimization.Solver.SparseMatrixCOO{I, K, V, Offset}, PolynomialOptimization.Solver.Indvals{K, V}}} where {I&lt;:Integer, K&lt;:Integer, V&lt;:Real, Offset}"><code>Base.append!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">append!(coo::SparseMatrixCOO, indvals::Indvals)</code></pre><p>Appends the data given in <code>indvals</code> into the next row in <code>coo</code>. Returns the index of the row that was added.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/AbstractSparseMatrixSolver.jl#L36-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.append!-Union{Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{I}, Tuple{PolynomialOptimization.Solver.SparseMatrixCOO{I, K, V, Offset}, PolynomialOptimization.Solver.IndvalsIterator{K, V, L, VT, VV} where {L, VT&lt;:AbstractVector{K}, VV&lt;:AbstractVector{V}}}} where {I&lt;:Integer, K&lt;:Integer, V&lt;:Real, Offset}" href="#Base.append!-Union{Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{I}, Tuple{PolynomialOptimization.Solver.SparseMatrixCOO{I, K, V, Offset}, PolynomialOptimization.Solver.IndvalsIterator{K, V, L, VT, VV} where {L, VT&lt;:AbstractVector{K}, VV&lt;:AbstractVector{V}}}} where {I&lt;:Integer, K&lt;:Integer, V&lt;:Real, Offset}"><code>Base.append!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">append!(coo::SparseMatrixCOO, indvals::IndvalsIterator)</code></pre><p>Appends the data given in <code>indvals</code> into successive rows in <code>coo</code> (<code>first(indvals)</code> to the first row, the next to the second, ...). Returns the range of indices of all rows that were added.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.IndvalsIterator"><code>IndvalsIterator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/AbstractSparseMatrixSolver.jl#L54-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.coo_to_csc!-Union{Tuple{Vararg{Union{Tuple{AbstractVector{K}, AbstractVector{V}}, PolynomialOptimization.Solver.SparseMatrixCOO{I, K, V, Offset}}}}, Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{I}} where {I&lt;:Integer, K&lt;:Integer, V&lt;:Real, Offset}" href="#PolynomialOptimization.Solver.coo_to_csc!-Union{Tuple{Vararg{Union{Tuple{AbstractVector{K}, AbstractVector{V}}, PolynomialOptimization.Solver.SparseMatrixCOO{I, K, V, Offset}}}}, Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{I}} where {I&lt;:Integer, K&lt;:Integer, V&lt;:Real, Offset}"><code>PolynomialOptimization.Solver.coo_to_csc!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coo_to_csc!(coo::Union{SparseMatrixCOO{I,K,V}},Tuple{FastVec{K},FastVec{V}}}...)</code></pre><p>Converts sparse COO matrix or vector representations, where the monomial indices of the <code>coo</code> matrices or the entries of the vectors can be arbitrarily sparse, to a CSC-based matrix representation with continuous columns, and the vectors are converted to dense ones. No more than two matrices may be supplied. The input data may be mutated; and this mutated data must be passed on to <a href="backend.html#PolynomialOptimization.MomentVector-Union{Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{Nc}, Tuple{Nr}, Tuple{PolynomialOptimization.Relaxation.AbstractRelaxation{&lt;:PolynomialOptimization.Problem{&lt;:PolynomialOptimization.IntPolynomials.IntPolynomial{var&quot;#s3&quot;, Nr, Nc, M} where {var&quot;#s3&quot;, M&lt;:(PolynomialOptimization.IntPolynomials.IntMonomialVector{Nr, Nc, I, E, T} where {I&lt;:Integer, E, T&lt;:(PolynomialOptimization.IntPolynomials.IntMonomial{Nr, Nc, I})})}}}, Vector{V}, K, PolynomialOptimization.Solver.SparseMatrixCOO{&lt;:Integer, K, V, Offset}, Vararg{PolynomialOptimization.Solver.SparseMatrixCOO{&lt;:Integer, K, V, Offset}}}} where {Nr, Nc, K&lt;:Integer, V&lt;:Real, Offset}"><code>MomentVector</code></a>. The following values are returned:</p><ul><li>number of distinct columns</li><li>for each input, if it is a matrix, a tuple containing the colptr, rowval, nzval vectors</li><li>for each input, if it is a vector, the corresponding dense vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/AbstractSparseMatrixSolver.jl#L121-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.MomentVector-Union{Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{Nc}, Tuple{Nr}, Tuple{PolynomialOptimization.Relaxation.AbstractRelaxation{&lt;:PolynomialOptimization.Problem{&lt;:PolynomialOptimization.IntPolynomials.IntPolynomial{var&quot;#s3&quot;, Nr, Nc, M} where {var&quot;#s3&quot;, M&lt;:(PolynomialOptimization.IntPolynomials.IntMonomialVector{Nr, Nc, I, E, T} where {I&lt;:Integer, E, T&lt;:(PolynomialOptimization.IntPolynomials.IntMonomial{Nr, Nc, I})})}}}, Vector{V}, K, PolynomialOptimization.Solver.SparseMatrixCOO{&lt;:Integer, K, V, Offset}, Vararg{PolynomialOptimization.Solver.SparseMatrixCOO{&lt;:Integer, K, V, Offset}}}} where {Nr, Nc, K&lt;:Integer, V&lt;:Real, Offset}" href="#PolynomialOptimization.MomentVector-Union{Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{Nc}, Tuple{Nr}, Tuple{PolynomialOptimization.Relaxation.AbstractRelaxation{&lt;:PolynomialOptimization.Problem{&lt;:PolynomialOptimization.IntPolynomials.IntPolynomial{var&quot;#s3&quot;, Nr, Nc, M} where {var&quot;#s3&quot;, M&lt;:(PolynomialOptimization.IntPolynomials.IntMonomialVector{Nr, Nc, I, E, T} where {I&lt;:Integer, E, T&lt;:(PolynomialOptimization.IntPolynomials.IntMonomial{Nr, Nc, I})})}}}, Vector{V}, K, PolynomialOptimization.Solver.SparseMatrixCOO{&lt;:Integer, K, V, Offset}, Vararg{PolynomialOptimization.Solver.SparseMatrixCOO{&lt;:Integer, K, V, Offset}}}} where {Nr, Nc, K&lt;:Integer, V&lt;:Real, Offset}"><code>PolynomialOptimization.MomentVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MomentVector(relaxation::AbstractRelaxation, moments::Vector{&lt;:Real},
    slack::Integer, coo::SparseMatrixCOO...)</code></pre><p>Given the moments vector as obtained from a <a href="backend.html#PolynomialOptimization.Solver.AbstractSparseMatrixSolver"><code>AbstractSparseMatrixSolver</code></a> solver, convert it to a <a href="reference.html#PolynomialOptimization.MomentVector"><code>MomentVector</code></a>. Note that this function is not fully type-stable, as the result may be based either on a dense or sparse vector depending on the relaxation. To establish the mapping between the solver output and the actual moments, all the column-sorted COO data (i.e., as returned by <a href="backend.html#PolynomialOptimization.Solver.coo_to_csc!-Union{Tuple{Vararg{Union{Tuple{AbstractVector{K}, AbstractVector{V}}, PolynomialOptimization.Solver.SparseMatrixCOO{I, K, V, Offset}}}}, Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{I}} where {I&lt;:Integer, K&lt;:Integer, V&lt;:Real, Offset}"><code>coo_to_csc!</code></a>) used in the problem construction needs to be passed on. <code>slack</code> must contain the current value of the <code>slack</code> field of the <code>AbstractSparseMatrixSolver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/AbstractSparseMatrixSolver.jl#L180-L189">source</a></section></article><h4 id="[AbstractAPISolver](@ref)"><a class="docs-heading-anchor" href="#[AbstractAPISolver](@ref)"><a href="backend.html#PolynomialOptimization.Solver.AbstractAPISolver"><code>AbstractAPISolver</code></a></a><a id="[AbstractAPISolver](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[AbstractAPISolver](@ref)" title="Permalink"></a></h4><p>This solver type accumulates the data continuously by the means of API calls provided by the solver. The monomials therefore have to have contiguously defined indices from the beginning. This is done by internal bookkeeping; however, it requires the implementation of an additional callback function <a href="backend.html#Base.append!-Union{Tuple{K}, Tuple{PolynomialOptimization.Solver.AbstractAPISolver{K}, K}} where K&lt;:Integer"><code>append!</code></a> to add new monomials to the solver. After the optimization is done, the optimal moment vector (the decision variables for moment optimization, the constraint duals for SOS optimization) can be constructed using <a href="backend.html#PolynomialOptimization.MomentVector-Union{Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{Nc}, Tuple{Nr}, Tuple{PolynomialOptimization.Relaxation.AbstractRelaxation{&lt;:PolynomialOptimization.Problem{&lt;:PolynomialOptimization.IntPolynomials.IntPolynomial{var&quot;#s3&quot;, Nr, Nc, M} where {var&quot;#s3&quot;, M&lt;:(PolynomialOptimization.IntPolynomials.IntMonomialVector{Nr, Nc, I, E, T} where {I&lt;:Integer, E, T&lt;:(PolynomialOptimization.IntPolynomials.IntMonomial{Nr, Nc, I})})}}}, Vector{V}, K, PolynomialOptimization.Solver.SparseMatrixCOO{&lt;:Integer, K, V, Offset}, Vararg{PolynomialOptimization.Solver.SparseMatrixCOO{&lt;:Integer, K, V, Offset}}}} where {Nr, Nc, K&lt;:Integer, V&lt;:Real, Offset}"><code>MomentVector</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.AbstractAPISolver" href="#PolynomialOptimization.Solver.AbstractAPISolver"><code>PolynomialOptimization.Solver.AbstractAPISolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractAPISolver{K&lt;:Integer,T,V} &lt;: AbstractSolver{T,V}</code></pre><p>Superclass for a solver that requires new variables/constraints to be added via API calls. Solvers that are of this type must implement <a href="backend.html#Base.append!-Union{Tuple{K}, Tuple{PolynomialOptimization.Solver.AbstractAPISolver{K}, K}} where K&lt;:Integer"><code>append!</code></a> in such a way that they directly add a variable (moment-case) to or constraint (SOS-case) to the solver. Concrete types that inherit from <code>AbstractAPISolver</code> must have a property <code>mon_to_solver::Dict{FastKey{K},T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/AbstractAPISolver.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.append!-Union{Tuple{K}, Tuple{PolynomialOptimization.Solver.AbstractAPISolver{K}, K}} where K&lt;:Integer" href="#Base.append!-Union{Tuple{K}, Tuple{PolynomialOptimization.Solver.AbstractAPISolver{K}, K}} where K&lt;:Integer"><code>Base.append!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">append!(solver::AbstractAPISolver{K}, key::K)</code></pre><p>Appends at least one new variable (moment-case) or constraint (SOS-case) to the solver <code>state</code> that represents the monomial given by <code>key</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/AbstractAPISolver.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.MomentVector-Union{Tuple{V}, Tuple{K}, Tuple{Nc}, Tuple{Nr}, Tuple{PolynomialOptimization.Relaxation.AbstractRelaxation{&lt;:PolynomialOptimization.Problem{&lt;:PolynomialOptimization.IntPolynomials.IntPolynomial{var&quot;#s3&quot;, Nr, Nc, M} where {var&quot;#s3&quot;, M&lt;:(PolynomialOptimization.IntPolynomials.IntMonomialVector{Nr, Nc, I, E, T} where {I&lt;:Integer, E, T&lt;:(PolynomialOptimization.IntPolynomials.IntMonomial{Nr, Nc, I})})}}}, Vector{V}, PolynomialOptimization.Solver.AbstractAPISolver{K}}} where {Nr, Nc, K&lt;:Integer, V&lt;:Real}" href="#PolynomialOptimization.MomentVector-Union{Tuple{V}, Tuple{K}, Tuple{Nc}, Tuple{Nr}, Tuple{PolynomialOptimization.Relaxation.AbstractRelaxation{&lt;:PolynomialOptimization.Problem{&lt;:PolynomialOptimization.IntPolynomials.IntPolynomial{var&quot;#s3&quot;, Nr, Nc, M} where {var&quot;#s3&quot;, M&lt;:(PolynomialOptimization.IntPolynomials.IntMonomialVector{Nr, Nc, I, E, T} where {I&lt;:Integer, E, T&lt;:(PolynomialOptimization.IntPolynomials.IntMonomial{Nr, Nc, I})})}}}, Vector{V}, PolynomialOptimization.Solver.AbstractAPISolver{K}}} where {Nr, Nc, K&lt;:Integer, V&lt;:Real}"><code>PolynomialOptimization.MomentVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MomentVector(relaxation::AbstractRelaxation, moments::Vector{&lt;:Real},
    solver::AbstractAPISolver)</code></pre><p>Given the moments vector as obtained from an <a href="backend.html#PolynomialOptimization.Solver.AbstractAPISolver"><code>AbstractAPISolver</code></a>, convert it to a <a href="reference.html#PolynomialOptimization.MomentVector"><code>MomentVector</code></a>. Note that this function is not fully type-stable, as the result may be based either on a dense or sparse vector depending on the relaxation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/AbstractAPISolver.jl#L30-L36">source</a></section></article><h4 id="Defining-solver-capabilities"><a class="docs-heading-anchor" href="#Defining-solver-capabilities">Defining solver capabilities</a><a id="Defining-solver-capabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-solver-capabilities" title="Permalink"></a></h4><p>There are some functions that should be implemented to tell <code>PolynomialOptimization</code> what kind of data the solver expects and which cones are supported; these should return constants.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.supports_rotated_quadratic" href="#PolynomialOptimization.Solver.supports_rotated_quadratic"><code>PolynomialOptimization.Solver.supports_rotated_quadratic</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">supports_rotated_quadratic(::AbstractSolver)</code></pre><p>Indicates the solver support for rotated quadratic cones: if <code>true</code>, the rotated second-order cone <span>$2x_1x_2 \geq \sum_{i \geq 3} x_i^2$</span> is supported. The default implementation returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Support.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.supports_quadratic" href="#PolynomialOptimization.Solver.supports_quadratic"><code>PolynomialOptimization.Solver.supports_quadratic</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">supports_quadratic(::AbstractSolver)</code></pre><p>Indicates the solver support for the quadratic cone: if <code>true</code>, the second-order cone <span>$x_1^2 \geq \\sum_{i \geq 2} x_i^2$</span> is supported. The default implementation returns the same value as <a href="backend.html#PolynomialOptimization.Solver.supports_rotated_quadratic"><code>supports_rotated_quadratic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Support.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.supports_psd_complex" href="#PolynomialOptimization.Solver.supports_psd_complex"><code>PolynomialOptimization.Solver.supports_psd_complex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">supports_psd_complex(::AbstractSolver)</code></pre><p>This function indicates whether the solver natively supports a complex-valued PSD cone. If it returns <code>false</code> (default), the complex-valued PSD constraints will be rewritten into real-valued PSD constraints; this is completely transparent for the solver. If the function returns <code>true</code>, the solver must additionally implement <a href="backend.html#PolynomialOptimization.Solver.add_var_psd_complex!"><code>add_var_psd_complex!</code></a> and <a href="backend.html#PolynomialOptimization.Solver.add_constr_psd_complex!"><code>add_constr_psd_complex!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Support.jl#L22-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.supports_dd" href="#PolynomialOptimization.Solver.supports_dd"><code>PolynomialOptimization.Solver.supports_dd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">supports_dd(::AbstractSolver)</code></pre><p>This function indicates whether the solver natively supports a diagonally-dominant cone (or its dual for the moment case). If it returns <code>false</code> (default), the constraint will be rewritten in terms of multiple <span>$\ell_\infty$</span>/<span>$\ell_1$</span> norm constraints (if supported, see <a href="backend.html#PolynomialOptimization.Solver.supports_lnorm"><code>supports_lnorm</code></a>), together with slack variables and equality constraints. If these <span>$\ell$</span>-norm constraints are also not supported, linear constraints will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Support.jl#L32-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.supports_dd_complex" href="#PolynomialOptimization.Solver.supports_dd_complex"><code>PolynomialOptimization.Solver.supports_dd_complex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">supports_dd_complex(::AbstractSolver)</code></pre><p>This function indicates whether the solver natively supports a complex-valued diagonally-dominant cone (or its dual for the moment case). If it returns <code>false</code> (default), the constraint will be rewritten in terms of quadratic constraints (if supported, see <a href="backend.html#PolynomialOptimization.Solver.supports_quadratic"><code>supports_quadratic</code></a>) or multiple <span>$\ell_\infty$</span>/<span>$\ell_1$</span> norm constraints (if supported, see <a href="backend.html#PolynomialOptimization.Solver.supports_lnorm_complex"><code>supports_lnorm_complex</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Support.jl#L42-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.supports_lnorm" href="#PolynomialOptimization.Solver.supports_lnorm"><code>PolynomialOptimization.Solver.supports_lnorm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">supports_lnorm(::AbstractSolver)</code></pre><p>Indicates the solver support for <span>$\ell_\infty$</span> (in the moment case) and <span>$\ell_1$</span> (in the SOS case) norm cones: if <code>true</code>, the cone <span>$x_1 \geq \max_{i \geq 2} \lvert x_i\rvert$</span> or <span>$x_1 \geq \sum_{i \geq 2} \lvert x_i\rvert$</span> is supported. The default implementation returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Support.jl#L52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.supports_lnorm_complex" href="#PolynomialOptimization.Solver.supports_lnorm_complex"><code>PolynomialOptimization.Solver.supports_lnorm_complex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">supports_lnorm_complex(::AbstractSolver)</code></pre><p>Indicates the solver support for complex-valued <span>$\ell_\infty$</span> (in the moment case) and <span>$\ell_1$</span> (in the SOS case) norm cones: if <code>true</code>, the cone <span>$x_1 \geq \max_{i \geq 2} \lvert\operatorname{Re} x_i + \mathrm i \operatorname{Im} x_i\rvert$</span> or <span>$x_1 \geq \sum_{i \geq 2} \lvert\operatorname{Re} x_i + \mathrm i \operatorname{Im} x_i\rvert$</span> is supported. The default implementation returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Support.jl#L61-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.supports_sdd" href="#PolynomialOptimization.Solver.supports_sdd"><code>PolynomialOptimization.Solver.supports_sdd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">supports_sdd(::AbstractSolver)</code></pre><p>This function indicates whether the solver natively supports a scaled diagonally-dominant cone (or its dual for the moment case). If it returns <code>false</code> (default), the constraints will be rewritten in terms of multiple rotated quadratic or quadratic constraints, one of which must be supported (see <a href="backend.html#PolynomialOptimization.Solver.supports_rotated_quadratic"><code>supports_rotated_quadratic</code></a> and <a href="backend.html#PolynomialOptimization.Solver.supports_quadratic"><code>supports_quadratic</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Support.jl#L71-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.supports_sdd_complex" href="#PolynomialOptimization.Solver.supports_sdd_complex"><code>PolynomialOptimization.Solver.supports_sdd_complex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">supports_sdd_complex(::AbstractSolver)</code></pre><p>This function indicates whether the solver natively supports a complex-valued scaled diagonally-dominant cone (or its dual for the moment case). If it returns <code>false</code> (default), the constraints will be rewritten in terms of multiple rotated quadratic or quadratic constraints, one of which must be supported (see <a href="backend.html#PolynomialOptimization.Solver.supports_rotated_quadratic"><code>supports_rotated_quadratic</code></a> and <a href="backend.html#PolynomialOptimization.Solver.supports_quadratic"><code>supports_quadratic</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Support.jl#L80-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.PSDIndextype" href="#PolynomialOptimization.Solver.PSDIndextype"><code>PolynomialOptimization.Solver.PSDIndextype</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PSDIndextype{Tri}</code></pre><p>Union for all supported types in which a solver can represent a PSD matrix.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeMatrixCartesian"><code>PSDIndextypeMatrixCartesian</code></a>, <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeVector"><code>PSDIndextypeVector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/DataTypes.jl#L224-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.PSDIndextypeMatrixCartesian" href="#PolynomialOptimization.Solver.PSDIndextypeMatrixCartesian"><code>PolynomialOptimization.Solver.PSDIndextypeMatrixCartesian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PSDIndextypeMatrixCartesian(triangle, offset) &lt;: PSDIndextype</code></pre><p>The solver implements PSD matrix constraints by using a monolithic PSD matrix variable or an LMI-style representation. Entries from the variable are obtained (or put into the LMI) by using a cartesian index of two integers of the type parameter <code>T</code> of the <a href="backend.html#PolynomialOptimization.Solver.AbstractSolver"><code>AbstractSolver</code></a>. This index represents one triangle of the matrix (the lower if <code>triangle === :L</code>, the upper if <code>triangle === :U</code>). The first entry has the index <code>(offset, offset)</code>, typically either <code>0</code> or <code>1</code>.</p><p>If this index type is used with <a href="backend.html#PolynomialOptimization.Solver.primal_moment_setup!"><code>primal_moment_setup!</code></a>, the resulting data will be an iterator through <a href="backend.html#PolynomialOptimization.Solver.SparseMatrixCOO"><code>SparseMatrixCOO</code></a>. In this case, <code>triangle === :F</code> is also permitted, resulting in the full triangle.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Note that even if only one triangle is indexed, it is assumed that the solver will by default populate the other triangle in a completely symmetric way. This corresponds to the typical behavior of solvers that expose PSD variables and allow accessing elements in them via sparse symmetric matrices where only one triangle is given, but the other half is implicit.</p></div></div><p>See also <a href="backend.html#PolynomialOptimization.Solver.PSDMatrixCartesian"><code>PSDMatrixCartesian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/DataTypes.jl#L160-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.PSDIndextypeVector" href="#PolynomialOptimization.Solver.PSDIndextypeVector"><code>PolynomialOptimization.Solver.PSDIndextypeVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PSDIndextypeVector(triangle[, scaling]) &lt;: PSDIndextype</code></pre><p>The solver implements PSD matrix constraints by demanding that the matrixization of a vector of decision variables be PSD. This index type is not permitted for use with <a href="backend.html#PolynomialOptimization.Solver.primal_moment_setup!"><code>primal_moment_setup!</code></a>.</p><p>If <code>triangle === :F</code>, the vector is formed by stacking all the columns of the matrix. <code>scaling</code> should be omitted.</p><p>If <code>triangle === :L</code>, the columns of the lower triangle are assumed to be stacked <em>and scaled</em>, i.e., off-diagonal variables that enter the cone are implicitly multiplied by <code>1 / scaling</code> in the matrix; so the coefficients will already be premultiplied by <code>scaling</code> (for the <a href="backend.html#PolynomialOptimization.Solver.add_constr_psd!"><code>add_constr_psd!</code></a> case) or by <code>1 / scaling</code> (for the <a href="backend.html#PolynomialOptimization.Solver.add_var_psd!-Union{Tuple{V}, Tuple{T}, Tuple{PolynomialOptimization.Solver.AbstractSolver{T, V}, Int64, PolynomialOptimization.Solver.PSDMatrixCartesian{T, V}}} where {T, V}"><code>add_var_psd!</code></a> case). The default value for <code>scaling</code> is <span>$sqrt2$</span>; however, the parameter has to be specified explictly in order to make sure the scaling has the correct type. Note: if no scaling is desired, the preferred value is <code>true</code>, which is equivalent to a multiplicative identity; however, the multiplication can be completely removed during compilation. This is because the value <code>false</code>, which would mean that alll off-diagonal entries are set to zero, is explicitly forbidden.</p><p>If <code>triangle === :U</code>, the columns of the upper triangle are assumed to be stacked and scaled.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.IndvalsIterator"><code>IndvalsIterator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/DataTypes.jl#L188-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.PSDIndextypeCOOVectorized" href="#PolynomialOptimization.Solver.PSDIndextypeCOOVectorized"><code>PolynomialOptimization.Solver.PSDIndextypeCOOVectorized</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PSDIndextypeCOOVectorized(triangle[, scaling], offset)</code></pre><p>The solver implements constraints on a monolithic PSD matrix variable using row-by-row scalar products with the vectorized matrix. During vectorization, only the specified triangle is retained. This index type is valid only for the use with <a href="backend.html#PolynomialOptimization.Solver.primal_moment_setup!"><code>primal_moment_setup!</code></a>.</p><p>If <code>triangle === :F</code>, the full matrix is stacked column-wise; <code>scaling</code> should be omitted.</p><p>If <code>triangle === :L</code>, the columns of the lower triangled are assumed to be stacked <em>and scaled</em>, i.e., off-diagonal variables that enter the cone are implicitly multiplied by <code>1 / scaling</code> in the matrix; so the coefficients will already be premultiplied by <code>1 / scaling</code>. If the solver internally works with the vectorized version, the appropriate value is probably <span>$\sqrt2$</span>; if the solver automatically rewrites everything for full matrices, the appropriate value is either <code>true</code> or <span>$2$</span>.</p><p>If <code>triangle === :U</code>, the column of the upper triangle are assumed to be stacked and scaled.</p><p>This all refers to the column index of the constraint matrix, where the row index is the index of the constraint. The data is supplied in COO form with specified offset and may be converted to CSC or CSR as desired.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/DataTypes.jl#L233-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.psd_indextype" href="#PolynomialOptimization.Solver.psd_indextype"><code>PolynomialOptimization.Solver.psd_indextype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">psd_indextype(::AbstractSolver)</code></pre><p>This function must indicate in which format the solver expects its data for PSD variables. The return type must be an instance of a <a href="backend.html#PolynomialOptimization.Solver.PSDIndextype"><code>PSDIndextype</code></a> subtype.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeMatrixCartesian"><code>PSDIndextypeMatrixCartesian</code></a>, <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeVector"><code>PSDIndextypeVector</code></a>, <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeCOOVectorized"><code>PSDIndextypeCOOVectorized</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/DataTypes.jl#L272-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.negate_fix" href="#PolynomialOptimization.Solver.negate_fix"><code>PolynomialOptimization.Solver.negate_fix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">negate_fix(::AbstractSolver)</code></pre><p>Depending on the exact definition of equality constraints (where to put the minus), the dual solutions, i.e., the SOS decomposition, may yield wrong values; then define this function to return <code>true</code>, which will pass the equality constraints with opposite sign.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L285-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.negate_free" href="#PolynomialOptimization.Solver.negate_free"><code>PolynomialOptimization.Solver.negate_free</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">negate_free(::AbstractSolver)</code></pre><p>Depending on the exact definition of equality constraints (where to put the minus), the dual solutions, i.e., the SOS decomposition, may yield wrong values; then define this function to return <code>true</code>, which will flip the sign of free variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L346-L351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.prepend_fix" href="#PolynomialOptimization.Solver.prepend_fix"><code>PolynomialOptimization.Solver.prepend_fix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepend_fix(::AbstractSolver)</code></pre><p>If this method yields <code>true</code> (default), fixed constraints will be created before all others. If it is <code>false</code>, PSD (or nonnegative) constraints will be created first.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Note that this does not imply a global order; if DD or SDD cones are used, fixed constraints may still appear at an arbitrary position. However, this method guarantees the order with respect to cones that will use the same monomial indices.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L294-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.prepend_free" href="#PolynomialOptimization.Solver.prepend_free"><code>PolynomialOptimization.Solver.prepend_free</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepend_free(::AbstractSolver)</code></pre><p>If this method yields <code>true</code> (default), free variables will be created before all others. If it is <code>false</code>, PSD (or nonnegative) variables will be created first.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Note that this does not imply a global order; if DD or SDD cones are used, free variables may still appear at an arbitrary position. However, this method guarantees the order with respect to cones that will use the same monomial indices.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L354-L363">source</a></section></article><h4 id="Working-with-data-from-the-interface"><a class="docs-heading-anchor" href="#Working-with-data-from-the-interface">Working with data from the interface</a><a id="Working-with-data-from-the-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-data-from-the-interface" title="Permalink"></a></h4><p>The interface functions that need to be implemented will get their data in the form of index-value pairs or a specific structure related to the desired matrix format.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.Indvals" href="#PolynomialOptimization.Solver.Indvals"><code>PolynomialOptimization.Solver.Indvals</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Indvals{T,V}</code></pre><p>Supertype for an iterable that returns a <code>Tuple{T,V}</code> on iteration, where the first is a variable/constraint index and the second its coefficient in the constraint matrix. The parameters of the type correspond to those in <a href="backend.html#PolynomialOptimization.Solver.AbstractSolver"><code>AbstractSolver</code></a>. The properties <code>indices</code> and <code>values</code> can be accessed and will give <code>AbstractVector</code>s of the appropriate type. Note that the fields should only be used if an iterative approach is not feasible, as they might be constructed on-demand (this will only happen for the first two indvals in the standard quadratic cone, all other elements can be accessed with zero cost).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/DataTypes.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.PSDMatrixCartesian" href="#PolynomialOptimization.Solver.PSDMatrixCartesian"><code>PolynomialOptimization.Solver.PSDMatrixCartesian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PSDMatrixCartesian</code></pre><p>An iterable that returns matrix elements of a PSD cone. Iterating through it will give <code>Pair</code>s with keys that contain the <a href="backend.html#PolynomialOptimization.Solver.mindex"><code>mindex</code></a> of the monomial, and a 3-Tuple of <code>AbstractVector</code>s as the values which contain the row and column indices together with their coefficients to describe where the monomial appears. Note that the vectors will be reused in every iteration.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeMatrixCartesian"><code>PSDIndextypeMatrixCartesian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/DataTypes.jl#L92-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.IndvalsIterator" href="#PolynomialOptimization.Solver.IndvalsIterator"><code>PolynomialOptimization.Solver.IndvalsIterator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IndvalsIterator{T,V}</code></pre><p>An iterable that returns consecutive elements in a vectorized PSD cone. This type stores a vector of indices and values together with information about the length of the individual subsequences. Iterating through it will give <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a> that contain views into the indices and the values. The vector of indices is available via <code>SparseArrays.rowvals</code>, the vector of values via <code>SparseArrays.nonzeros</code>, and the lengths of the subsequences via <code>Base.index_lengths</code>.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeVector"><code>PSDIndextypeVector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/DataTypes.jl#L39-L49">source</a></section></article><h4 id="Interface-for-the-moment-optimization"><a class="docs-heading-anchor" href="#Interface-for-the-moment-optimization">Interface for the moment optimization</a><a id="Interface-for-the-moment-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-for-the-moment-optimization" title="Permalink"></a></h4><p>The custom implementation of <a href="backend.html#PolynomialOptimization.Solver.poly_optimize-Tuple{Val, PolynomialOptimization.Relaxation.AbstractRelaxation, PolynomialOptimization.Relaxation.RelaxationGroupings}-backend"><code>poly_optimize</code></a> first has to set up all the necessary initial data; then, a call to <a href="backend.html#PolynomialOptimization.Solver.moment_setup!"><code>moment_setup!</code></a> is sufficient to trigger the process.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.moment_setup!" href="#PolynomialOptimization.Solver.moment_setup!"><code>PolynomialOptimization.Solver.moment_setup!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">moment_setup!(state::AbstractSolver, relaxation::AbstractRelaxation,
    groupings::RelaxationGroupings[; representation])</code></pre><p>Sets up all the necessary moment matrices, variables, constraints, and objective of a polynomial optimization problem <code>problem</code> according to the values given in <code>grouping</code> (where the first entry corresponds to the basis of the objective, the second of the equality, the third of the inequality, and the fourth of the PSD constraints). The function returns a <code>Vector{&lt;:Vector{&lt;:Tuple{Symbol,Any}}}</code> that contains internal information on the problem. This information is required to obtain dual variables and re-optimize the problem and should be stored in the <code>state</code>.</p><p>The following methods must be implemented by a solver to make this function work:</p><ul><li><a href="backend.html#PolynomialOptimization.Solver.mindex"><code>mindex</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_nonnegative!"><code>add_constr_nonnegative!</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_rotated_quadratic!"><code>add_constr_rotated_quadratic!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_rotated_quadratic"><code>supports_rotated_quadratic</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_quadratic!"><code>add_constr_quadratic!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_quadratic"><code>supports_quadratic</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_psd!"><code>add_constr_psd!</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_psd_complex!"><code>add_constr_psd_complex!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_psd_complex"><code>supports_psd_complex</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_dddual!"><code>add_constr_dddual!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_dd"><code>supports_dd</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_dddual_complex!"><code>add_constr_dddual_complex!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_dd_complex"><code>supports_dd_complex</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_linf!"><code>add_constr_linf!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_lnorm"><code>supports_lnorm</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_linf_complex!"><code>add_constr_linf_complex!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_lnorm_complex"><code>supports_lnorm_complex</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_sdddual!"><code>add_constr_sdddual!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_sdd"><code>supports_sdd</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_sdddual_complex!"><code>add_constr_sdddual_complex!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_sdd_complex"><code>supports_sdd_complex</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_fix_prepare!"><code>add_constr_fix_prepare!</code></a> (optional)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_fix!"><code>add_constr_fix!</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_fix_finalize!"><code>add_constr_fix_finalize!</code></a> (optional)</li><li><a href="backend.html#PolynomialOptimization.Solver.fix_objective!"><code>fix_objective!</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_slack!"><code>add_var_slack!</code></a></li></ul><div class="admonition is-warning"><header class="admonition-header">Indices</header><div class="admonition-body"><p>The variable indices used in all solver functions directly correspond to the indices given back by <a href="backend.html#PolynomialOptimization.Solver.mindex"><code>mindex</code></a>. However, in a sparse problem there may be far fewer indices present; therefore, when the problem is finally given to the solver, care must be taken to eliminate all unused indices. The functionality provided by <a href="backend.html#PolynomialOptimization.Solver.AbstractAPISolver"><code>AbstractAPISolver</code></a> and <a href="backend.html#PolynomialOptimization.Solver.AbstractSparseMatrixSolver"><code>AbstractSparseMatrixSolver</code></a> already takes care of this.</p></div></div><div class="admonition is-info"><header class="admonition-header">Order</header><div class="admonition-body"><p>The individual constraint types can be added in any order (including interleaved).</p></div></div><div class="admonition is-info"><header class="admonition-header">Representation</header><div class="admonition-body"><p>This function may also be used to describe simplified cones such as the (scaled) diagonally dominant one. The <code>representation</code> parameter can be used to define a representation that is employed for the individual groupings. This may either be an instance of a <a href="reference.html#PolynomialOptimization.Solver.RepresentationMethod"><code>RepresentationMethod</code></a> - which requires the method to be independent of the dimension of the grouping - or a callable. In the latter case, it will be passed as a first parameter an identifier<sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup> of the current conic variable, and as a second parameter the side dimension of its matrix. The method must then return a <a href="reference.html#PolynomialOptimization.Solver.RepresentationMethod"><code>RepresentationMethod</code></a> instance.</p></div></div><p>See also <a href="backend.html#PolynomialOptimization.Solver.sos_setup!"><code>sos_setup!</code></a>, <a href="backend.html#PolynomialOptimization.Solver.moment_add_matrix!"><code>moment_add_matrix!</code></a>, <a href="backend.html#PolynomialOptimization.Solver.moment_add_equality!"><code>moment_add_equality!</code></a>, <a href="reference.html#PolynomialOptimization.Solver.RepresentationMethod"><code>RepresentationMethod</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentHelpers.jl#L1962-L2016">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.moment_add_matrix!" href="#PolynomialOptimization.Solver.moment_add_matrix!"><code>PolynomialOptimization.Solver.moment_add_matrix!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">moment_add_matrix!(state::AbstractSolver, grouping::IntMonomialVector,
    constraint::Union{&lt;:IntPolynomial,&lt;:AbstractMatrix{&lt;:IntPolynomial}},
    representation::RepresentationMethod=RepresentationPSD())</code></pre><p>Parses a constraint in the moment hierarchy with a basis given in <code>grouping</code> (this might also be a partial basis due to sparsity), premultiplied by <code>constraint</code> (which may be the unit polynomial for the moment matrix) and calls the appropriate solver functions to set up the problem structure according to <code>representation</code>.</p><p>To make this function work for a solver, implement the following low-level primitives:</p><ul><li><a href="backend.html#PolynomialOptimization.Solver.mindex"><code>mindex</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_nonnegative!"><code>add_constr_nonnegative!</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_rotated_quadratic!"><code>add_constr_rotated_quadratic!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_rotated_quadratic"><code>supports_rotated_quadratic</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_quadratic!"><code>add_constr_quadratic!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_quadratic"><code>supports_quadratic</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_psd!"><code>add_constr_psd!</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_psd_complex!"><code>add_constr_psd_complex!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_psd_complex"><code>supports_psd_complex</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_dddual!"><code>add_constr_dddual!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_dd"><code>supports_dd</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_dddual_complex!"><code>add_constr_dddual_complex!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_dd_complex"><code>supports_dd_complex</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_linf!"><code>add_constr_linf!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_lnorm"><code>supports_lnorm</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_linf_complex!"><code>add_constr_linf_complex!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_lnorm_complex"><code>supports_lnorm_complex</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_sdddual!"><code>add_constr_sdddual!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_sdd"><code>supports_sdd</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_sdddual_complex!"><code>add_constr_sdddual_complex!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_sdd_complex"><code>supports_sdd_complex</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_slack!"><code>add_var_slack!</code></a></li></ul><p>Usually, this function does not have to be called explicitly; use <a href="backend.html#PolynomialOptimization.Solver.moment_setup!"><code>moment_setup!</code></a> instead.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.moment_add_equality!"><code>moment_add_equality!</code></a>, <a href="reference.html#PolynomialOptimization.Solver.RepresentationMethod"><code>RepresentationMethod</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentHelpers.jl#L1635-L1663">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.moment_add_equality!" href="#PolynomialOptimization.Solver.moment_add_equality!"><code>PolynomialOptimization.Solver.moment_add_equality!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">moment_add_equality!(state::AbstractSolver, grouping::IntMonomialVector,
    constraint::IntPolynomial)</code></pre><p>Parses a polynomial equality constraint for moments and calls the appropriate solver functions to set up the problem structure. <code>grouping</code> contains the basis that will be squared in the process to generate the prefactor.</p><p>To make this function work for a solver, implement the following low-level primitives:</p><ul><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_fix_prepare!"><code>add_constr_fix_prepare!</code></a> (optional)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_fix!"><code>add_constr_fix!</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_fix_finalize!"><code>add_constr_fix_finalize!</code></a> (optional)</li></ul><p>Usually, this function does not have to be called explicitly; use <a href="backend.html#PolynomialOptimization.Solver.moment_setup!"><code>moment_setup!</code></a> instead.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.moment_add_matrix!"><code>moment_add_matrix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentHelpers.jl#L1724-L1739">source</a></section></article><p>For this to work, the following methods (or a subset as previously indicated) must be implemented.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_constr_nonnegative!" href="#PolynomialOptimization.Solver.add_constr_nonnegative!"><code>PolynomialOptimization.Solver.add_constr_nonnegative!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_constr_nonnegative!(state::AbstractSolver{T,V}, indvals::Indvals{T,V}) where {T,V}</code></pre><p>Add a nonnegative constraint to the solver that contains the decision variables (columns in the linear constraint matrix) indexed according to <code>indvals</code>. Falls back to the vector-valued version if not implemented.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L7-L15">source</a></section><section><div><pre><code class="language-julia hljs">add_constr_nonnegative!(state::AbstractSolver{T,V},
    indvals::IndvalsIterator{T,V}) where {T,V}</code></pre><p>Adds multiple nonnegative constraints to the solver that contain the decision variables (columns in the linear constraint matrix) indices according to the entries in <code>indvals</code>. Falls back to calling the scalar-valued version multiple times if not implemented.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.IndvalsIterator"><code>IndvalsIterator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L19-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_constr_rotated_quadratic!" href="#PolynomialOptimization.Solver.add_constr_rotated_quadratic!"><code>PolynomialOptimization.Solver.add_constr_rotated_quadratic!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_constr_rotated_quadratic!(state::AbstractSolver{T,V},
    indvals::IndvalsIterator{T,V}) where {T,V}</code></pre><p>Adds a rotated quadratic constraint to the <code>N = length(indvals)</code> linear combinations of decision variables (columns in the conic constraint matrix) indexed according to the <code>indvals</code>. This will read (where <span>$X_i$</span> is <span>$\mathit{indvals}_i.\mathit{values} \cdot x_{\mathit{indvals}_i.\mathit{indices}}$</span>) <span>$X_1, X_2 \geq 0$</span>, <span>$2X_1 X_2 \geq \sum_{i = 3}^N X_i^2$</span>.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>, <a href="backend.html#PolynomialOptimization.Solver.IndvalsIterator"><code>IndvalsIterator</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Number of parameters</header><div class="admonition-body"><p>In the real-valued case, <code>indvals</code> is always of length three, in the complex case, it is of length four. If the scaled diagonally dominant representation is requested, <code>indvals</code> can have any length.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_rotated_quadratic"><code>supports_rotated_quadratic</code></a> returns <code>true</code> for the given state. If (rotated) quadratic constraints are unsupported, a fallback to a 2x2 PSD constraint is used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L60-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_constr_quadratic!" href="#PolynomialOptimization.Solver.add_constr_quadratic!"><code>PolynomialOptimization.Solver.add_constr_quadratic!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_constr_quadratic!(state::AbstractSolver{T,V}, indvals::IndvalsIterator{T,V}) where {T,V}</code></pre><p>Adds a quadratic constraint to the <code>N = length(indvals)</code> linear combinations of decision variables (columns in the conic constraint matrix) indexed according to the <code>indvals</code>. This will read (where <span>$X_i$</span> is <span>$\mathit{indvals}_i.\mathit{values} \cdot x_{\mathit{indvals}_i.\mathit{indices}}$</span>) <span>$X_1 \geq 0$</span>, <span>$X_1^2 \geq \sum_{i = 2}^N X_i^2$</span>.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>, <a href="backend.html#PolynomialOptimization.Solver.IndvalsIterator"><code>IndvalsIterator</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Number of parameters</header><div class="admonition-body"><p>In the real-valued case, <code>indvals</code> is always of length three, in the complex case, it is of length four. If the scaled diagonally dominant representation is requested, <code>indvals</code> can have any length.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_quadratic"><code>supports_quadratic</code></a> returns <code>true</code> for the given state. If (rotated) quadratic constraints are unsupported, a fallback to a 2x2 PSD constraint is used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L38-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_constr_psd!" href="#PolynomialOptimization.Solver.add_constr_psd!"><code>PolynomialOptimization.Solver.add_constr_psd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_constr_psd!(state::AbstractSolver{T,V}, dim::Integer,
    data::PSDMatrixCartesian{T,V}) where {T,V}</code></pre><p>Add a PSD constraint of side dimension <code>dim</code> ≥ 3 to the solver. Its requested triangle is indexed according to the return value of <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a>); these elements make up a linear matrix inequality with variables given by the keys when iterating through <code>data</code>, which are of the type <code>T</code>. Note that if <a href="backend.html#PolynomialOptimization.Solver.add_constr_quadratic!"><code>add_constr_quadratic!</code></a> is not implemented, <code>dim</code> may also be <code>2</code>. This method is called if <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a> returns a <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeMatrixCartesian"><code>PSDIndextypeMatrixCartesian</code></a>.</p><div class="admonition is-category-hint"><header class="admonition-header">Complex-valued PSD variables</header><div class="admonition-body"><p>Note that this function will also be called for complex-valued PSD cones if <a href="backend.html#PolynomialOptimization.Solver.supports_psd_complex"><code>supports_psd_complex</code></a> returns <code>false</code>. The data will have been rewritten in terms of a real-valued PSD cone, which doubles the dimension. If the solver natively supports complex-valued PSD cones, <a href="backend.html#PolynomialOptimization.Solver.add_constr_psd_complex!"><code>add_constr_psd_complex!</code></a> must be implemented.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L83-L97">source</a></section><section><div><pre><code class="language-julia hljs">add_constr_psd!(state::AbstractSolver{T,V}, dim::Integer, data::IndvalsIterator{T,V}) where {T,V}</code></pre><p>Add a PSD constraint of side dimension <code>dim</code> ≥ 3 to the solver. <code>data</code> is an iterable through the elements of the PSD matrix one-by-one, in the order specified by <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a>. The individual entries are <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>. This method is called if <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a> returns a <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeVector"><code>PSDIndextypeVector</code></a>.</p><div class="admonition is-category-hint"><header class="admonition-header">Complex-valued PSD variables</header><div class="admonition-body"><p>Note that this function will also be called for complex-valued PSD cones if <a href="backend.html#PolynomialOptimization.Solver.supports_psd_complex"><code>supports_psd_complex</code></a> returns <code>false</code>. The data will have been rewritten in terms of a real-valued PSD cone, which doubles the dimension. If the solver natively supports complex-valued PSD cones, <a href="backend.html#PolynomialOptimization.Solver.add_constr_psd_complex!"><code>add_constr_psd_complex!</code></a> must be implemented.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L100-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_constr_psd_complex!" href="#PolynomialOptimization.Solver.add_constr_psd_complex!"><code>PolynomialOptimization.Solver.add_constr_psd_complex!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_constr_psd_complex!(state::AbstractSolver{T,V}, dim::Int,
    data::PSDMatrixCartesian{T,Complex{V}}) where {T,V}</code></pre><p>Add a Hermitian PSD constraint of side dimension <code>dim</code> ≥ 3 to the solver. Its requested triangle is indexed according to the return value of <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a>); these elements make up a linear matrix inequality with variables given by the keys when iterating through <code>data</code>, which are of the type <code>T</code>. The real part of any coefficient corresponds to the coefficient in front of the real part of the matrix entry, the imaginary part is the coefficient for the imaginary part of the matrix entry. Note that if <a href="backend.html#PolynomialOptimization.Solver.add_constr_quadratic!"><code>add_constr_quadratic!</code></a> is not implemented, <code>dim</code> may also be <code>2</code>. This method is called if <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a> returns a <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeMatrixCartesian"><code>PSDIndextypeMatrixCartesian</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_psd_complex"><code>supports_psd_complex</code></a> is defined to return <code>true</code> for the given state.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L116-L129">source</a></section><section><div><pre><code class="language-julia hljs">add_constr_psd_complex!(state::AbstractSolver{T,V}, dim::Int, data::IndvalsIterator{T,V}) where {T,V}</code></pre><p>Add a Hermitian PSD constraint of side dimension <code>dim</code> ≥ 3 to the solver. <code>data</code> is an iterable through the elements of the PSD matrix one-by-one, in the order specified by <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a>. The individual entries are <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>. This method is called if <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a> returns a <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeVector"><code>PSDIndextypeVector</code></a>. Regardless of the travelling order, for diagonal elements, there will be exactly one entry, which is the real part. For off-diagonal elements, the real part will be followed by the imaginary part. Therefore, the coefficients are real-valued.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_psd_complex"><code>supports_psd_complex</code></a> is defined to return <code>true</code> for the given state.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L132-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_constr_dddual!" href="#PolynomialOptimization.Solver.add_constr_dddual!"><code>PolynomialOptimization.Solver.add_constr_dddual!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_constr_dddual!(state::AbstractSolver{T,V}, dim::Integer, data::IndvalsIterator{T,V},
    u) where {T,V}</code></pre><p>Add a constraint for membership in the dual cone to diagonally dominant matrices to the solver. <code>data</code> is an iterator through the scaled lower triangle of the matrix. A basis change is induced by <code>u</code>, with the meaning for the primal cone that <code>M ∈ DD(u) ⇔ M = uᵀ Q u</code> with <code>Q ∈ DD</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_dd"><code>supports_dd</code></a> returns <code>true</code> for the given state. If diagonally dominant cones are not supported directly, a fallback to a columnwise representation in terms of <span>$\ell_\infty$</span> norms will be used (or the fallbacks if this norm is not supported).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L148-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_constr_dddual_complex!" href="#PolynomialOptimization.Solver.add_constr_dddual_complex!"><code>PolynomialOptimization.Solver.add_constr_dddual_complex!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_constr_dddual_complex!(state::AbstractSolver{T,V}, dim::Integer,
    data::IndvalsIterator{T,V}, u) where {T,V}</code></pre><p>Add a constraint for membership in the dual cone to complex-valued diagonally dominant matrices to the solver. <code>data</code> is an iterator through the scaled lower triangle of the matrix. A basis change is induced by <code>u</code>, with the meaning for the primal cone that <code>M ∈ DD(u) ⇔ M = u† Q u</code> with <code>Q ∈ DD</code>. For diagonal elements, there will be exactly one entry, which is the real part. For off-diagonal elements, the real part will be followed by the imaginary part. Therefore, the coefficients are real-valued.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_dd_complex"><code>supports_dd_complex</code></a> returns <code>true</code> for the given state. If complex-valued diagonally dominant cones are not supported directly, a fallback to quadratic constraints on the complex-valued data is tried first (if supported), followed by a columnwise representation in terms of <span>$\ell_\infty$</span> norms or their fallback on the realification of the matrix data if not.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L165-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_constr_linf!" href="#PolynomialOptimization.Solver.add_constr_linf!"><code>PolynomialOptimization.Solver.add_constr_linf!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_constr_linf!(state::AbstractSolver{T,V}, indvals::IndvalsIterator{T,V}) where {T,V}</code></pre><p>Adds an <span>$\ell_\infty$</span> norm constraint to the <code>N = length(indvals)</code> linear combinations of decision variables (columns in the conic constraint matrix) indexed according to the <code>indvals</code>. This will read (where <span>$X_i$</span> is <span>$\mathit{indvals}_i.\mathit{values} \cdot x_{\mathit{indvals}_i.\mathit{indices}}$</span>) <span>$X_1 \geq \max_{i &gt; 2} \lvert X_i\rvert$</span>.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>, <a href="backend.html#PolynomialOptimization.Solver.IndvalsIterator"><code>IndvalsIterator</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_lnorm"><code>supports_lnorm</code></a> returns <code>true</code> for the given state. If <span>$\ell_\infty$</span> norm constraints are unsupported, a fallback to multiple linear constraints will be used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L185-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_constr_linf_complex!" href="#PolynomialOptimization.Solver.add_constr_linf_complex!"><code>PolynomialOptimization.Solver.add_constr_linf_complex!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_constr_linf_complex!(state, indvals::IndvalsIterator{T,V}) where {T,V&lt;:Real}</code></pre><p>Same as <a href="backend.html#PolynomialOptimization.Solver.add_constr_linf!"><code>add_constr_linf!</code></a>, but now two successive items in <code>indvals</code> (starting from the second) are interpreted as determining the real and imaginary part of a component of the <span>$\ell_\infty$</span> norm cone.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_lnorm_complex"><code>supports_lnorm_complex</code></a> returns <code>true</code> for the given state. If complex-valued <span>$\ell_\infty$</span> norm constraints are unsupported, a fallback to multiple linear constraints and quadratic cones will be used. If <a href="backend.html#PolynomialOptimization.Solver.supports_quadratic"><code>supports_quadratic</code></a> is not <code>true</code>, complex-valued DD cones cannot be used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L203-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_constr_sdddual!" href="#PolynomialOptimization.Solver.add_constr_sdddual!"><code>PolynomialOptimization.Solver.add_constr_sdddual!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_constr_sdddual!(state::AbstractSolver{T,V}, dim::Integer, data::IndvalsIterator{T,V},
    u) where {T,V}</code></pre><p>Add a constraint for membership in the dual cone to scaled diagonally dominant matrices to the solver. <code>data</code> is an iterator through the (unscaled) lower triangle of the matrix. A basis change is induced by <code>u</code>, with the meaning for the primal cone that <code>M ∈ SDD(u) ⇔ M = uᵀ Q u</code> with <code>Q ∈ SDD</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_sdd"><code>supports_sdd</code></a> returns <code>true</code> for the given state. If scaled diagonally dominant cones are not supported directly, a fallback to (rotated) quadratic cones will be used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L218-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_constr_sdddual_complex!" href="#PolynomialOptimization.Solver.add_constr_sdddual_complex!"><code>PolynomialOptimization.Solver.add_constr_sdddual_complex!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_constr_sdddual_complex!(state::AbstractSolver{T,V}, dim::Integer,
    data::IndvalsIterator{T,V}, u) where {T,V}</code></pre><p>Add a constraint for membership in the dual cone to complex-valued scaled diagonally dominant matrices to the solver. <code>data</code> is an iterator through the (unscaled) lower triangle of the matrix. A basis change is induced by <code>u</code>, with the meaning for the primal cone that <code>M ∈ SDD(u) ⇔ M = u† Q u</code> with <code>Q ∈ SDD</code>. For diagonal elements, there will be exactly one entry, which is the real part. For off-diagonal elements, the real part will be followed by the imaginary part. Therefore, the coefficients are real-valued.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_sdd_complex"><code>supports_sdd_complex</code></a> returns <code>true</code> for the given state. If complex-valued sclaed diagonally dominant cones are not supported directly, a fallback to quadratic constraints is automatically performed.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L234-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_constr_fix_prepare!" href="#PolynomialOptimization.Solver.add_constr_fix_prepare!"><code>PolynomialOptimization.Solver.add_constr_fix_prepare!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_constr_fix_prepare!(state::AbstractSolver, num::Int)</code></pre><p>Prepares to add exactly <code>num</code> constraints that are fixed to a certain value; the actual data is then put into the solver by subsequent calls of <a href="backend.html#PolynomialOptimization.Solver.add_constr_fix!"><code>add_constr_fix!</code></a> and the whole transaction is completed by <a href="backend.html#PolynomialOptimization.Solver.add_constr_fix_finalize!"><code>add_constr_fix_finalize!</code></a>. The return value of this function is passed on as <code>constrstate</code> to <a href="backend.html#PolynomialOptimization.Solver.add_constr_fix!"><code>add_constr_fix!</code></a>. The default implementation does nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L251-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_constr_fix!" href="#PolynomialOptimization.Solver.add_constr_fix!"><code>PolynomialOptimization.Solver.add_constr_fix!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_constr_fix!(state::AbstractSolver{T,V}, constrstate, indvals::Indvals{T,V},
    rhs::V) where {T,V}</code></pre><p>Add a constraint fixed to <code>rhs</code> to the solver that is composed of all variables (columns in the linear constraint matrix) indexed according to <code>indvals</code>. The parameter <code>constrstate</code> is, upon first call, the value returned by <a href="backend.html#PolynomialOptimization.Solver.add_constr_fix_prepare!"><code>add_constr_fix_prepare!</code></a>; and on all further calls, it will be the return value of the previous call. Note that <code>rhs</code> will almost always be zero, so if the right-hand side is represented by a sparse vector, it is worth checking for this value (the compiler will be able to remove the check).</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L261-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_constr_fix_finalize!" href="#PolynomialOptimization.Solver.add_constr_fix_finalize!"><code>PolynomialOptimization.Solver.add_constr_fix_finalize!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_constr_fix_finalize!(state::AbstractSolver, constrstate)</code></pre><p>Finishes the addition of fixed constraints to <code>state</code>; the value of <code>constrstate</code> is the return value of the last call to <a href="backend.html#PolynomialOptimization.Solver.add_constr_fix!"><code>add_constr_fix!</code></a>. The default implementation does nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L276-L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.fix_objective!" href="#PolynomialOptimization.Solver.fix_objective!"><code>PolynomialOptimization.Solver.fix_objective!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fix_objective!(state, indvals::Indvals)</code></pre><p>Puts the variables indexed according to <code>indvals</code> into the objective (that is to be minimized). This function will be called exactly once by <a href="backend.html#PolynomialOptimization.Solver.moment_setup!"><code>moment_setup!</code></a> after all variables and constraints have been set up.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L307-L314">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_slack!" href="#PolynomialOptimization.Solver.add_var_slack!"><code>PolynomialOptimization.Solver.add_var_slack!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_slack!(state::AbstractSolver{T}, num::Int)</code></pre><p>Creates <code>num</code> slack variables in the problem. Slack variables must be free. The result should be an abstract vector (typically a unit range) that contains the indices of all created slack variables. The indices should be of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/MomentInterface.jl#L317-L322">source</a></section></article><h4 id="Interface-for-the-SOS-optimization"><a class="docs-heading-anchor" href="#Interface-for-the-SOS-optimization">Interface for the SOS optimization</a><a id="Interface-for-the-SOS-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-for-the-SOS-optimization" title="Permalink"></a></h4><p>This is in complete analogy to the moment case; the entry point is now <a href="backend.html#PolynomialOptimization.Solver.sos_setup!"><code>sos_setup!</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.sos_setup!" href="#PolynomialOptimization.Solver.sos_setup!"><code>PolynomialOptimization.Solver.sos_setup!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sos_setup!(state::AbstractSolver, relaxation::AbstractRelaxation,
    groupings::RelaxationGroupings[; representation])</code></pre><p>Sets up all the necessary SOS matrices, free variables, objective, and constraints of a polynomial optimization problem <code>problem</code> according to the values given in <code>grouping</code> (where the first entry corresponds to the basis of the objective, the second of the equality, the third of the inequality, and the fourth of the PSD constraints). The function returns a <code>Vector{&lt;:Vector{&lt;:Tuple{Symbol,Any}}}</code> that contains internal information on the problem. This information is required to obtain dual constraints and re-optimize the problem and should be stored in the <code>state</code>.</p><p>The following methods must be implemented by a solver to make this function work:</p><ul><li><a href="backend.html#PolynomialOptimization.Solver.mindex"><code>mindex</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_nonnegative!-Union{Tuple{V}, Tuple{T}, Tuple{PolynomialOptimization.Solver.AbstractSolver{T, V}, PolynomialOptimization.Solver.Indvals{T, V}}} where {T, V}"><code>add_var_nonnegative!</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_rotated_quadratic!"><code>add_var_rotated_quadratic!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_rotated_quadratic"><code>supports_rotated_quadratic</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_quadratic!"><code>add_var_quadratic!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_quadratic"><code>supports_quadratic</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_psd!-Union{Tuple{V}, Tuple{T}, Tuple{PolynomialOptimization.Solver.AbstractSolver{T, V}, Int64, PolynomialOptimization.Solver.PSDMatrixCartesian{T, V}}} where {T, V}"><code>add_var_psd!</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_psd_complex!"><code>add_var_psd_complex!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_psd_complex"><code>supports_psd_complex</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_dd!"><code>add_var_dd!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_dd"><code>supports_dd</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_dd_complex!"><code>add_var_dd_complex!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_dd_complex"><code>supports_dd_complex</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_l1!"><code>add_var_l1!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_lnorm"><code>supports_lnorm</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_l1_complex!"><code>add_var_l1_complex!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_lnorm_complex"><code>supports_lnorm_complex</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_sdd!"><code>add_var_sdd!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_sdd"><code>supports_sdd</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_sdd_complex!"><code>add_var_sdd_complex!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_sdd_complex"><code>supports_sdd_complex</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_free_prepare!"><code>add_var_free_prepare!</code></a> (optional)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_free!"><code>add_var_free!</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_free_finalize!"><code>add_var_free_finalize!</code></a> (optional)</li><li><a href="backend.html#PolynomialOptimization.Solver.fix_constraints!"><code>fix_constraints!</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_slack!"><code>add_constr_slack!</code></a></li></ul><div class="admonition is-warning"><header class="admonition-header">Indices</header><div class="admonition-body"><p>The constraint indices used in all solver functions directly correspond to the indices given back by <a href="backend.html#PolynomialOptimization.Solver.mindex"><code>mindex</code></a>. However, in a sparse problem there may be far fewer indices present; therefore, when the problem is finally given to the solver, care must be taken to eliminate all unused indices. The functionality provided by <a href="backend.html#PolynomialOptimization.Solver.AbstractAPISolver"><code>AbstractAPISolver</code></a> and <a href="backend.html#PolynomialOptimization.Solver.AbstractSparseMatrixSolver"><code>AbstractSparseMatrixSolver</code></a> already takes care of this.</p></div></div><div class="admonition is-info"><header class="admonition-header">Order</header><div class="admonition-body"><p>The individual variable types can be added in any order (including interleaved).</p></div></div><div class="admonition is-info"><header class="admonition-header">Representation</header><div class="admonition-body"><p>This function may also be used to describe simplified cones such as the (scaled) diagonally dominant one. The <code>representation</code> parameter can be used to define a representation that is employed for the individual groupings. This may either be an instance of a <a href="reference.html#PolynomialOptimization.Solver.RepresentationMethod"><code>RepresentationMethod</code></a> - which requires the method to be independent of the dimension of the grouping - or a callable. In the latter case, it will be passed as a first parameter an identifier<sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup> of the current conic variable, and as a second parameter the side dimension of its matrix. The method must then return a <a href="reference.html#PolynomialOptimization.Solver.RepresentationMethod"><code>RepresentationMethod</code></a> instance.</p></div></div><p>See also <a href="backend.html#PolynomialOptimization.Solver.moment_setup!"><code>moment_setup!</code></a>, <a href="backend.html#PolynomialOptimization.Solver.sos_add_matrix!"><code>sos_add_matrix!</code></a>, <a href="backend.html#PolynomialOptimization.Solver.sos_add_equality!"><code>sos_add_equality!</code></a>, <a href="reference.html#PolynomialOptimization.Solver.RepresentationMethod"><code>RepresentationMethod</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSHelpers.jl#L96-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.sos_add_matrix!" href="#PolynomialOptimization.Solver.sos_add_matrix!"><code>PolynomialOptimization.Solver.sos_add_matrix!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sos_add_matrix!(state::AbstractSolver, grouping::IntMonomialVector,
    constraint::Union{&lt;:IntPolynomial,&lt;:AbstractMatrix{&lt;:IntPolynomial}},
    representation::RepresentationMethod=RepresentationPSD())</code></pre><p>Parses a SOS constraint with a basis given in <code>grouping</code> (this might also be a partial basis due to sparsity), premultiplied by <code>constraint</code> (which may be the unit polynomial for the SOS cone membership) and calls the appropriate solver functions to set up the problem structure according to <code>representation</code>.</p><p>To make this function work for a solver, implement the following low-level primitives:</p><ul><li><a href="backend.html#PolynomialOptimization.Solver.mindex"><code>mindex</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_nonnegative!-Union{Tuple{V}, Tuple{T}, Tuple{PolynomialOptimization.Solver.AbstractSolver{T, V}, PolynomialOptimization.Solver.Indvals{T, V}}} where {T, V}"><code>add_var_nonnegative!</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_rotated_quadratic!"><code>add_var_rotated_quadratic!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_rotated_quadratic"><code>supports_rotated_quadratic</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_quadratic!"><code>add_var_quadratic!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_quadratic"><code>supports_quadratic</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_psd!-Union{Tuple{V}, Tuple{T}, Tuple{PolynomialOptimization.Solver.AbstractSolver{T, V}, Int64, PolynomialOptimization.Solver.PSDMatrixCartesian{T, V}}} where {T, V}"><code>add_var_psd!</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_psd_complex!"><code>add_var_psd_complex!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_psd_complex"><code>supports_psd_complex</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_dd!"><code>add_var_dd!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_dd"><code>supports_dd</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_dd_complex!"><code>add_var_dd_complex!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_dd_complex"><code>supports_dd_complex</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_l1!"><code>add_var_l1!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_lnorm"><code>supports_lnorm</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_l1_complex!"><code>add_var_l1_complex!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_lnorm_complex"><code>supports_lnorm_complex</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_sdd!"><code>add_var_sdd!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_sdd"><code>supports_sdd</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_sdd_complex!"><code>add_var_sdd_complex!</code></a> (optional, then set <a href="backend.html#PolynomialOptimization.Solver.supports_sdd_complex"><code>supports_sdd_complex</code></a> to <code>true</code>)</li><li><a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_constr_slack!"><code>add_constr_slack!</code></a></li></ul><p>Usually, this function does not have to be called explicitly; use <a href="backend.html#PolynomialOptimization.Solver.sos_setup!"><code>sos_setup!</code></a> instead.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.sos_add_equality!"><code>sos_add_equality!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSHelpers.jl#L47-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.sos_add_equality!" href="#PolynomialOptimization.Solver.sos_add_equality!"><code>PolynomialOptimization.Solver.sos_add_equality!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sos_add_equality!(state::AbstractSolver, grouping::IntMonomialVector,
    constraint::IntPolynomial)</code></pre><p>Parses a polynomial equality constraint for sums-of-squares and calls the appropriate solver functions to set up the problem structure. <code>grouping</code> contains the basis that will be squared in the process to generate the prefactor.</p><p>To make this function work for a solver, implement the following low-level primitives:</p><ul><li><a href="backend.html#PolynomialOptimization.Solver.add_var_free_prepare!"><code>add_var_free_prepare!</code></a> (optional)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_free!"><code>add_var_free!</code></a> (required)</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_free_finalize!"><code>add_var_free_finalize!</code></a> (optional)</li></ul><p>Usually, this function does not have to be called explicitly; use <a href="backend.html#PolynomialOptimization.Solver.sos_setup!"><code>sos_setup!</code></a> instead.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.sos_add_matrix!"><code>sos_add_matrix!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSHelpers.jl#L78-L93">source</a></section></article><p>The following methods (or a subset as previously indicated) must be implemented.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_nonnegative!-Union{Tuple{V}, Tuple{T}, Tuple{PolynomialOptimization.Solver.AbstractSolver{T, V}, PolynomialOptimization.Solver.Indvals{T, V}}} where {T, V}" href="#PolynomialOptimization.Solver.add_var_nonnegative!-Union{Tuple{V}, Tuple{T}, Tuple{PolynomialOptimization.Solver.AbstractSolver{T, V}, PolynomialOptimization.Solver.Indvals{T, V}}} where {T, V}"><code>PolynomialOptimization.Solver.add_var_nonnegative!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_nonnegative!(state::AbstractSolver{T,V}, indvals::Indvals{T,V}) where {T,V}</code></pre><p>Add a nonnegative decision variable to the solver and put its value into the linear constraints (rows in the linear constraint matrix) indexed according to <code>indvals</code>. Falls back to the vector-valued version if not implemented.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_nonnegative!-Union{Tuple{V}, Tuple{T}, Tuple{PolynomialOptimization.Solver.AbstractSolver{T, V}, PolynomialOptimization.Solver.IndvalsIterator{T, V, L, VT, VV} where {L, VT&lt;:AbstractVector{T}, VV&lt;:AbstractVector{V}}}} where {T, V}" href="#PolynomialOptimization.Solver.add_var_nonnegative!-Union{Tuple{V}, Tuple{T}, Tuple{PolynomialOptimization.Solver.AbstractSolver{T, V}, PolynomialOptimization.Solver.IndvalsIterator{T, V, L, VT, VV} where {L, VT&lt;:AbstractVector{T}, VV&lt;:AbstractVector{V}}}} where {T, V}"><code>PolynomialOptimization.Solver.add_var_nonnegative!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_nonnegative!(state::AbstractSolver{T,V}, indvals::IndvalsIterator{T,V}) where {T,V}</code></pre><p>Add multiple nonnegative decision variables to the solver and put their values into the linear constraints (rows in the linear constraint matrix) indexed according to the entries in <code>indvals</code>. Falls back to calling the scalar-valued version multiple times if not implemented.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.IndvalsIterator"><code>IndvalsIterator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L19-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_rotated_quadratic!" href="#PolynomialOptimization.Solver.add_var_rotated_quadratic!"><code>PolynomialOptimization.Solver.add_var_rotated_quadratic!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_rotated_quadratic!(state::AbstractSolver{T,V},
    indvals::IndvalsIterator{T,V}) where {T,V}</code></pre><p>Adds decision variables in a rotated quadratic cone to the solver and put their values into the linear constraints (rows in the linear constraint matrix), indexed according to <code>indvals</code>. The <code>N = length(indvals)</code> variables will satisfy <span>$x_1, x_2 \geq 0$</span>, <span>$2x_1 x_2 \geq \sum_{i = 3}^N x_i^2$</span>.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>, <a href="backend.html#PolynomialOptimization.Solver.IndvalsIterator"><code>IndvalsIterator</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Number of parameters</header><div class="admonition-body"><p>In the real-valued case, <code>indvals</code> is always of length three, in the complex case, it is of length four. If the scaled diagonally dominant representation is requested, <code>indvals</code> can have any length.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_quadratic"><code>supports_quadratic</code></a> returns <code>true</code> for the given state. If (rotated) quadratic constraints are unsupported, a fallback to a 2x2 PSD variable is used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L72-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_quadratic!" href="#PolynomialOptimization.Solver.add_var_quadratic!"><code>PolynomialOptimization.Solver.add_var_quadratic!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_quadratic!(state::AbstractSolver{T,V}, indvals::IndvalsIterator{T,V}) where {T,V}</code></pre><p>Adds decision variables in a quadratic cone to the solver and put their values into the linear constraints (rows in the linear constraint matrix), indexed according to <code>indvals</code>. The <code>N = length(indvals)</code> variables will satisfy <span>$x_1 \geq 0$</span>, <span>$x_1^2 \geq \sum_{i = 2}^N x_i^2$</span>.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>, <a href="backend.html#PolynomialOptimization.Solver.IndvalsIterator"><code>IndvalsIterator</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Number of parameters</header><div class="admonition-body"><p>In the real-valued case, <code>indvals</code> is always of length three, in the complex case, it is of length four. If the scaled diagonally dominant representation is requested, <code>indvals</code> can have any length.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_quadratic"><code>supports_quadratic</code></a> returns <code>true</code> for the given state. If (rotated) quadratic constraints are unsupported, a fallback to a 2x2 PSD variable is used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L51-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_psd!-Union{Tuple{V}, Tuple{T}, Tuple{PolynomialOptimization.Solver.AbstractSolver{T, V}, Int64, PolynomialOptimization.Solver.PSDMatrixCartesian{T, V}}} where {T, V}" href="#PolynomialOptimization.Solver.add_var_psd!-Union{Tuple{V}, Tuple{T}, Tuple{PolynomialOptimization.Solver.AbstractSolver{T, V}, Int64, PolynomialOptimization.Solver.PSDMatrixCartesian{T, V}}} where {T, V}"><code>PolynomialOptimization.Solver.add_var_psd!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_psd!(state::AbstractSolver{T,V}, dim::Int,
    data::PSDMatrixCartesian{T,V}) where {T,V}</code></pre><p>Add a PSD variable of side dimension <code>dim</code> ≥ 3 to the solver. Its requested triangle is indexed according to the return value of <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a>); these elements of the matrix are put into the linear constraints (rows in the linear constraint matrix) indicated by the keys when iterating through <code>data</code>, which are of the type <code>T</code>, at positions and with coefficients given by their values. Note that if <a href="backend.html#PolynomialOptimization.Solver.add_var_quadratic!"><code>add_var_quadratic!</code></a> is not implemented, <code>dim</code> may also be <code>2</code>. This method is called if <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a> returns a <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeMatrixCartesian"><code>PSDIndextypeMatrixCartesian</code></a>.</p><div class="admonition is-category-hint"><header class="admonition-header">Complex-valued PSD variables</header><div class="admonition-body"><p>Note that this function will also be called for complex-valued PSD cones if <a href="backend.html#PolynomialOptimization.Solver.supports_psd_complex"><code>supports_psd_complex</code></a> returns <code>false</code>. The data will have been rewritten in terms of a real-valued PSD cone, which doubles the dimension. If the solver natively supports complex-valued PSD cones, <a href="backend.html#PolynomialOptimization.Solver.add_var_psd_complex!"><code>add_var_psd_complex!</code></a> must be implemented.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L94-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_psd!-Union{Tuple{V}, Tuple{T}, Tuple{PolynomialOptimization.Solver.AbstractSolver{T, V}, Int64, PolynomialOptimization.Solver.IndvalsIterator{T, V, L, VT, VV} where {L, VT&lt;:AbstractVector{T}, VV&lt;:AbstractVector{V}}}} where {T, V}" href="#PolynomialOptimization.Solver.add_var_psd!-Union{Tuple{V}, Tuple{T}, Tuple{PolynomialOptimization.Solver.AbstractSolver{T, V}, Int64, PolynomialOptimization.Solver.IndvalsIterator{T, V, L, VT, VV} where {L, VT&lt;:AbstractVector{T}, VV&lt;:AbstractVector{V}}}} where {T, V}"><code>PolynomialOptimization.Solver.add_var_psd!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_psd!(state::AbstractSolver{T,V}, dim::Int, data::IndvalsIterator{T,V}) where {T,V}</code></pre><p>Conceptually the same as above; but now, <code>data</code> is an iterable through the elements of the PSD variable one-by-one. The individual entries are <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>. This method is called if <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a> returns a <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeVector"><code>PSDIndextypeVector</code></a>.</p><div class="admonition is-category-hint"><header class="admonition-header">Complex-valued PSD variables</header><div class="admonition-body"><p>Note that this function will also be called for complex-valued PSD cones if <a href="backend.html#PolynomialOptimization.Solver.supports_psd_complex"><code>supports_psd_complex</code></a> returns <code>false</code>. The data will have been rewritten in terms of a real-valued PSD cone, which doubles the dimension. If the solver natively supports complex-valued PSD cones, <a href="backend.html#PolynomialOptimization.Solver.add_var_psd_complex!"><code>add_var_psd_complex!</code></a> must be implemented.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L112-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_psd_complex!" href="#PolynomialOptimization.Solver.add_var_psd_complex!"><code>PolynomialOptimization.Solver.add_var_psd_complex!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_psd_complex!(state::AbstractSolver{T,V}, dim::Int, data::PSDMatrixCartesian{T,Complex{V}}) where {T,V}</code></pre><p>Add a Hermitian PSD variable of side dimension <code>dim</code> ≥ 3 to the solver. Its requested triangle is indexed according to the return value of <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a>); these elements of the matrix are put into the linear constraints (rows in the linear constraint matrix) indicated by the keys when iterating through <code>data</code>, which are of the type <code>T</code>, at positions and with coefficients given by their values. The real part of the coefficient corresponds to the coefficient in front of the real part of the matrix entry, the imaginary part is the coefficient for the imaginary part of the matrix entry. Note that if <a href="backend.html#PolynomialOptimization.Solver.add_var_quadratic!"><code>add_var_quadratic!</code></a> is not implemented, <code>dim</code> may also be <code>2</code>. This method is called if <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a> returns a <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeMatrixCartesian"><code>PSDIndextypeMatrixCartesian</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_psd_complex"><code>supports_psd_complex</code></a> is defined to return <code>true</code> for the given state.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L179-L192">source</a></section><section><div><pre><code class="language-julia hljs">add_var_psd_complex!(state::AbstractSolver{T,V}, dim::Int,
    data::IndvalsIterator{T,V}) where {T,V}</code></pre><p>Conceptually the same as above; but now, <code>data</code> is an iterable through the elements of the PSD variable one-by-one. The individual entries are <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>. This method is called if <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a> returns a <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeVector"><code>PSDIndextypeVector</code></a>. Regardless of the travelling order, for diagonal elements, there will be exactly one entry, which is the real part. For off-diagonal elements, the real part will be followed by the imaginary part. Therefore, the coefficients are real-valued.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_psd_complex"><code>supports_psd_complex</code></a> is defined to return <code>true</code> for the given state.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L195-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_dd!" href="#PolynomialOptimization.Solver.add_var_dd!"><code>PolynomialOptimization.Solver.add_var_dd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_dd!(state::AbstractSolver{T,V}, dim::Integer, data::IndvalsIterator{T,V},
    u) where {T,V}</code></pre><p>Add a constraint for membership in the cone of diagonally dominant matrices to the solver. <code>data</code> is an iterator through the scaled lower triangle of the matrix. A basis change is induced by <code>u</code>, with the meaning that <code>M ∈ DD(u) ⇔ M = uᵀ Q u</code> with <code>Q ∈ DD</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_dd"><code>supports_dd</code></a> returns <code>true</code> for the given state. If diagonally dominant cones are not supported directly, a fallback to a columnwise representation in terms of <span>$\ell_1$</span> norms will be used (or the fallbacks if this norm is not supported).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L212-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_dd_complex!" href="#PolynomialOptimization.Solver.add_var_dd_complex!"><code>PolynomialOptimization.Solver.add_var_dd_complex!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_dd_complex!(state::AbstractSolver{T,V}, dim::Integer,
    data::IndvalsIterator{T,V}, u) where {T,V}</code></pre><p>Add a constraint for membership in the cone of complex-valued diagonally dominant matrices to the solver. <code>data</code> is an iterator hrough the scaled lower triangle of the matrix. A basis change is induced by <code>u</code>, with the meaning that <code>M ∈ DD(u) ⇔ M = u† Q u</code> with <code>Q ∈ DD</code>. For diagonal elements, there will be exactly one entry, which is the real part. For off-diagonal elements, the real part will be followed by the imaginary part. Therefore, the coefficients are real-valued.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_dd_complex"><code>supports_dd_complex</code></a> returns <code>true</code> for the given state. If complex-valued diagonally dominant cones are not supported directly, a fallback to quadratic cones on the complex-valued data is tried first (if supported), followed by a columnwise representation in terms of <span>$\ell_1$</span> norms or their fallback on the realification of the matrix data if not.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L229-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_l1!" href="#PolynomialOptimization.Solver.add_var_l1!"><code>PolynomialOptimization.Solver.add_var_l1!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_l1!(state::AbstractSolver{T,V}, indvals::IndvalsIterator{T,V}) where {T,V}</code></pre><p>Adds decision variables in an <span>$\ell_1$</span> norm cone to the solver and put their values into the linear constraints (rows in the linear constraint matrix), indexed according to the <code>indvals</code>. The <code>N = length(indvals)</code> variables will satisfy <span>$x_1 \geq \sum_{i = 2}^N \lvert x_i\rvert$</span>.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>, <a href="backend.html#PolynomialOptimization.Solver.IndvalsIterator"><code>IndvalsIterator</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_lnorm"><code>supports_lnorm</code></a> returns <code>true</code> for the given state. If <span>$\ell_\infty$</span> norm cones are unsupported, a fallback to multiple nonnegative variables will be used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L249-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_l1_complex!" href="#PolynomialOptimization.Solver.add_var_l1_complex!"><code>PolynomialOptimization.Solver.add_var_l1_complex!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_l1_complex!(state::AbstractSolver{T,V}, indvals::IndvalsIterator{T,V}) where {T,V}</code></pre><p>Same as <a href="backend.html#PolynomialOptimization.Solver.add_var_l1!"><code>add_var_l1!</code></a>, but now two successive items in <code>indvals</code> (starting from the second) are interpreted as determining the real and imaginary part of a component of the <span>$\ell_1$</span> norm variable.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_lnorm_complex"><code>supports_lnorm_complex</code></a> returns <code>true</code> for the given state. If complex-valued <span>$\ell_1$</span> norm cones are unsupported, a fallback to multiple nonnegative and quadratic variables will be used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L266-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_sdd!" href="#PolynomialOptimization.Solver.add_var_sdd!"><code>PolynomialOptimization.Solver.add_var_sdd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_sdd!(state::AbstractSolver{T,V}, dim::Integer, data::IndvalsIterator{T,V},
    u) where {T,V}</code></pre><p>Add a constraint for membership in the cone of scaled diagonally dominant matrices to the solver. <code>data</code> is an iterator through the (unscaled) lower triangle of the matrix. A basis change is induced by <code>u</code>, with the meaning that <code>M ∈ SDD(u) ⇔ M = uᵀ Q u</code> with <code>Q ∈ SDD</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_sdd"><code>supports_sdd</code></a> returns <code>true</code> for the given state. If scaled diagonally dominant cones are not supported directly, a fallback to (rotated) quadratic cones will be used.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L281-L292">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_sdd_complex!" href="#PolynomialOptimization.Solver.add_var_sdd_complex!"><code>PolynomialOptimization.Solver.add_var_sdd_complex!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_sdd_complex!(state::AbstractSolver{T,V}, dim::Integer,
    data::IndvalsIterator{T,V}, u) where {T,V}</code></pre><p>Add a constraint for membership in the cone of complex-valued scaled diagonally dominant matrices to the solver. <code>data</code> is an iterator through the (unscaled) lower triangle of the matrix. A basis change is induced by <code>u</code>, with the meaning that <code>M ∈ SDD(u) ⇔ M = u† Q u</code> with <code>Q ∈ SDD</code>. For diagonal elements, there will be exactly one entry, which is the real part. For off-diagonal elements, the real part will be followed by the imaginary part. Therefore, the coefficients are real-valued.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function will only be called if <a href="backend.html#PolynomialOptimization.Solver.supports_sdd_complex"><code>supports_sdd_complex</code></a> returns <code>true</code> for the given state. If complex-valued scaled diagonally dominant cones are not supported directly, a fallback to quadratic cones is automatically performed.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L297-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_free_prepare!" href="#PolynomialOptimization.Solver.add_var_free_prepare!"><code>PolynomialOptimization.Solver.add_var_free_prepare!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_free_prepare!(state::AbstractSolver, num::Int)</code></pre><p>Prepares to add exactly <code>num</code> free variables that may become part of the objective; the actual data is then put into the solver by subsequent calls of <a href="backend.html#PolynomialOptimization.Solver.add_var_free!"><code>add_var_free!</code></a> and the whole transaction is completed by <a href="backend.html#PolynomialOptimization.Solver.add_var_free_finalize!"><code>add_var_free_finalize!</code></a>. The return value of this function is passed on as <code>eqstate</code> to <a href="backend.html#PolynomialOptimization.Solver.add_var_free!"><code>add_var_free!</code></a>. The default implementation does nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L313-L320">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_free!" href="#PolynomialOptimization.Solver.add_var_free!"><code>PolynomialOptimization.Solver.add_var_free!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_free!(state::AbstractSolver{T,V}, eqstate, indvals::Indvals{T,V},
    obj::V) where {T,V}</code></pre><p>Add a free variable to the solver and put its value into the linear constraints (rows in the linear constraint matrix), indexed according to <code>indvals</code>. The variable should also be put into the objective with coefficient <code>obj</code> (which is likely to be zero). The parameter <code>eqstate</code> is, upon first call, the value returned by <a href="backend.html#PolynomialOptimization.Solver.add_var_free_prepare!"><code>add_var_free_prepare!</code></a>; and on all further calls, it will be the return value of the previous call.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L323-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_free_finalize!" href="#PolynomialOptimization.Solver.add_var_free_finalize!"><code>PolynomialOptimization.Solver.add_var_free_finalize!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_free_finalize!(state::AbstractSolver, eqstate)</code></pre><p>Finishes the addition of free variables to <code>state</code>; the value of <code>eqstate</code> is the return value of the last call to <a href="backend.html#PolynomialOptimization.Solver.add_var_free!"><code>add_var_free!</code></a>. The default implementation does nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L337-L343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.fix_constraints!" href="#PolynomialOptimization.Solver.fix_constraints!"><code>PolynomialOptimization.Solver.fix_constraints!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fix_constraints!(state::AbstractSolver{T,V}, indvals::Indvals{T,V}) where {T,V}</code></pre><p>Ensures that all constraints in the optimization problem are fixed to the values according to <code>indvals</code>. This function will be called exactly once by <a href="backend.html#PolynomialOptimization.Solver.sos_setup!"><code>sos_setup!</code></a> after all variables and constraints have been set up.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.Indvals"><code>Indvals</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L368-L375">source</a></section><section><div><pre><code class="language-julia hljs">fix_constraints(state::AbstractSolver{&lt;:Integer,V}, m::Int,
    indvals::Indvals{I,V}) where {I,V}</code></pre><p>Ensures that all constraints in the optimization problem are fixed to the values according to <code>indvals</code>. This form of the function is called from <a href="backend.html#PolynomialOptimization.Solver.primal_moment_setup!"><code>primal_moment_setup!</code></a>. <code>m</code> is the number of constraints in the solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L378-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_constr_slack!" href="#PolynomialOptimization.Solver.add_constr_slack!"><code>PolynomialOptimization.Solver.add_constr_slack!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_constr_slack!(state::AbstractSolver{T}, num::Int)</code></pre><p>Creates <code>num</code> linear fix-to-zero slack constraints in the problem (i.e., constraints that do not correspond to moments). The result should be an abstract vector (typically a unit range) that contains the indices of type <code>T</code> of all created slack constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L387-L393">source</a></section></article><h4 id="Interface-for-the-moment-optimization-in-primal-form"><a class="docs-heading-anchor" href="#Interface-for-the-moment-optimization-in-primal-form">Interface for the moment optimization in primal form</a><a id="Interface-for-the-moment-optimization-in-primal-form-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-for-the-moment-optimization-in-primal-form" title="Permalink"></a></h4><p>A very particular case is if the moment optimization should be done using semidefinite variables that the solver allows to define, but only as a single variable (not as a cone in which to put variables); this is the primal form, most suitable for SOS optimizations. However, there can be a good reason to use the primal form for moment optimizations instead: namely, if the solver can exploit a low-rank assumptions on this matrix. In this case, <code>poly_optimize</code> should call <a href="backend.html#PolynomialOptimization.Solver.primal_moment_setup!"><code>primal_moment_setup!</code></a> instead:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.primal_moment_setup!" href="#PolynomialOptimization.Solver.primal_moment_setup!"><code>PolynomialOptimization.Solver.primal_moment_setup!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">primal_moment_setup!(state::AbstractSolver, relaxation::AbstractRelaxation,
    groupings::RelaxationGroupings; verbose=false)</code></pre><p>Sets up all the necessary moment matrices, constraints, and objective of a polynomial optimization problem in primal form, i.e., for solvers which allow to declare monolithic semidefinite and nonnegative variables and linear constraints. While usually, the SOS form would be more suitable for such solvers, forcing the moment form in primal representation ensures that low-rank assumptions about the primal variable hold true, which can be exploited by some solvers. This function returns a <code>Vector{&lt;:Vector{&lt;:Tuple{Symbol,Any}}}</code> that contains internal information on the problem. This information is required to obtain dual variables and re-optimize the problem and should be stored in the <code>state</code>. It also returns an internal state that is important for the reconstruction of the moment matrices using <a href="backend.html#PolynomialOptimization.MomentVector-Union{Tuple{Offset}, Tuple{V}, Tuple{K}, Tuple{Nc}, Tuple{Nr}, Tuple{PolynomialOptimization.Relaxation.AbstractRelaxation{&lt;:PolynomialOptimization.Problem{&lt;:PolynomialOptimization.IntPolynomials.IntPolynomial{var&quot;#s3&quot;, Nr, Nc, M} where {var&quot;#s3&quot;, M&lt;:(PolynomialOptimization.IntPolynomials.IntMonomialVector{Nr, Nc, I, E, T} where {I&lt;:Integer, E, T&lt;:(PolynomialOptimization.IntPolynomials.IntMonomial{Nr, Nc, I})})}}}, Vector{V}, K, PolynomialOptimization.Solver.SparseMatrixCOO{&lt;:Integer, K, V, Offset}, Vararg{PolynomialOptimization.Solver.SparseMatrixCOO{&lt;:Integer, K, V, Offset}}}} where {Nr, Nc, K&lt;:Integer, V&lt;:Real, Offset}"><code>MomentVector</code></a>. The internal state has three properties that are part of the public interface:</p><ul><li><code>num_con::Int</code> is the number of constraints</li><li><code>num_nonneg::Int</code> is the number of nonnegative variables</li><li><code>psd_dim::FastVec{I}</code> holds the side dimensions of the PSD variables (where <code>I</code> is the index type of <code>state</code>)</li></ul><p>The following methods must be implemented by a solver to make this function work:</p><ul><li><a href="backend.html#PolynomialOptimization.Solver.mindex"><code>mindex</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_nonnegative!-Union{Tuple{V}, Tuple{I}, Tuple{PolynomialOptimization.Solver.AbstractSolver{&lt;:Integer, V}, Int64, Int64, PolynomialOptimization.Solver.SparseMatrixCOO{I, I, V}, Tuple{PolynomialOptimization.FastVector.FastVec{I}, PolynomialOptimization.FastVector.FastVec{V}}}} where {I, V}"><code>add_var_nonnegative!</code></a>, which is called no more than once</li><li><a href="backend.html#PolynomialOptimization.Solver.add_var_psd!-Union{Tuple{V}, Tuple{I}, Tuple{PolynomialOptimization.Solver.AbstractSolver{&lt;:Integer, V}, Int64, I, PolynomialOptimization.Solver.SparseMatrixCOO{I, I, V}, Union{Nothing, Tuple{PolynomialOptimization.FastVector.FastVec{I}, PolynomialOptimization.FastVector.FastVec{V}}}}} where {I, V}"><code>add_var_psd!</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.objective_indextype"><code>objective_indextype</code></a></li><li><a href="backend.html#PolynomialOptimization.Solver.fix_constraints!-Union{Tuple{V}, Tuple{PolynomialOptimization.Solver.AbstractSolver{&lt;:Integer, V}, Int64, PolynomialOptimization.Solver.Indvals{&lt;:Integer, V}}} where V"><code>fix_constraints!</code></a></li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>During the reformulation, the function is able to detect a certain class of unbounded or infeasible problem formulations. If this is the case, it will return <code>missing</code> without invoking the solver.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/PrimalMomentHelpers.jl#L486-L515">source</a></section></article><p>The following methods must be implemented:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_nonnegative!-Union{Tuple{V}, Tuple{I}, Tuple{PolynomialOptimization.Solver.AbstractSolver{&lt;:Integer, V}, Int64, Int64, PolynomialOptimization.Solver.SparseMatrixCOO{I, I, V}, Tuple{PolynomialOptimization.FastVector.FastVec{I}, PolynomialOptimization.FastVector.FastVec{V}}}} where {I, V}" href="#PolynomialOptimization.Solver.add_var_nonnegative!-Union{Tuple{V}, Tuple{I}, Tuple{PolynomialOptimization.Solver.AbstractSolver{&lt;:Integer, V}, Int64, Int64, PolynomialOptimization.Solver.SparseMatrixCOO{I, I, V}, Tuple{PolynomialOptimization.FastVector.FastVec{I}, PolynomialOptimization.FastVector.FastVec{V}}}} where {I, V}"><code>PolynomialOptimization.Solver.add_var_nonnegative!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_nonnegative!(state::AbstractSolver{&lt;:Integer,V}, m::Int, n::Int,
    data::SparseMatrixCOO{I,I,V}, obj::Tuple{FastVec{I},FastVec{V}}) where {I,V}</code></pre><p>This form of the function is called from <a href="backend.html#PolynomialOptimization.Solver.primal_moment_setup!"><code>primal_moment_setup!</code></a>. <code>m</code> is the number of total constraints, <code>n</code> the number of nonnegative variables; and the linear constraint matrix is given by <code>data</code>. The variables should be put into the objective according to <code>obj</code>. Note that the indices in <code>data</code> will have an offset as defined by the <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a>, while the indices in <code>obj</code> take their offset from <a href="backend.html#PolynomialOptimization.Solver.objective_indextype"><code>objective_indextype</code></a>.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.coo_to_csc!-Union{Tuple{offset}, Tuple{V}, Tuple{I}, Tuple{Integer, PolynomialOptimization.Solver.SparseMatrixCOO{I, I, V, offset}}} where {I, V, offset}"><code>coo_to_csc!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L35-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_psd!-Union{Tuple{V}, Tuple{I}, Tuple{PolynomialOptimization.Solver.AbstractSolver{&lt;:Integer, V}, Int64, I, PolynomialOptimization.Solver.SparseMatrixCOO{I, I, V}, Union{Nothing, Tuple{PolynomialOptimization.FastVector.FastVec{I}, PolynomialOptimization.FastVector.FastVec{V}}}}} where {I, V}" href="#PolynomialOptimization.Solver.add_var_psd!-Union{Tuple{V}, Tuple{I}, Tuple{PolynomialOptimization.Solver.AbstractSolver{&lt;:Integer, V}, Int64, I, PolynomialOptimization.Solver.SparseMatrixCOO{I, I, V}, Union{Nothing, Tuple{PolynomialOptimization.FastVector.FastVec{I}, PolynomialOptimization.FastVector.FastVec{V}}}}} where {I, V}"><code>PolynomialOptimization.Solver.add_var_psd!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_psd!(state::AbstractSolver{&lt;:Integer,V}, m::Int, dim::I,
    data::SparseMatrixCOO{I,I,V},
    obj::Union{Nothing,Tuple{FastVec{I},FastVec{V}}}) where {I,V}</code></pre><p>This form of the function is called from <a href="backend.html#PolynomialOptimization.Solver.primal_moment_setup!"><code>primal_moment_setup!</code></a> when both the <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a> and the <a href="backend.html#PolynomialOptimization.Solver.objective_indextype"><code>objective_indextype</code></a> are of type <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeCOOVectorized"><code>PSDIndextypeCOOVectorized</code></a>. Note that the triangles or scaling factors are allowed to be different. <code>m</code> is the number of constraints in the problem, and the first index in <code>data</code> always corresponds to the constraint index. The matrix also takes part in the objective unless the <code>obj</code> parameter is <code>nothing</code>.</p><p>There are various possible variations in which the data can be passed, as documented for the following functions.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.coo_to_csc!-Union{Tuple{offset}, Tuple{V}, Tuple{I}, Tuple{Integer, PolynomialOptimization.Solver.SparseMatrixCOO{I, I, V, offset}}} where {I, V, offset}"><code>coo_to_csc!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L126-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_psd!-Union{Tuple{V}, Tuple{I}, Tuple{PolynomialOptimization.Solver.AbstractSolver{&lt;:Integer, V}, Int64, I, PolynomialOptimization.Solver.SparseMatrixCOO{I, I, V}, Union{Nothing, Tuple{Tuple{PolynomialOptimization.FastVector.FastVec{I}, PolynomialOptimization.FastVector.FastVec{I}}, PolynomialOptimization.FastVector.FastVec{V}}}}} where {I, V}" href="#PolynomialOptimization.Solver.add_var_psd!-Union{Tuple{V}, Tuple{I}, Tuple{PolynomialOptimization.Solver.AbstractSolver{&lt;:Integer, V}, Int64, I, PolynomialOptimization.Solver.SparseMatrixCOO{I, I, V}, Union{Nothing, Tuple{Tuple{PolynomialOptimization.FastVector.FastVec{I}, PolynomialOptimization.FastVector.FastVec{I}}, PolynomialOptimization.FastVector.FastVec{V}}}}} where {I, V}"><code>PolynomialOptimization.Solver.add_var_psd!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_psd!(state::AbstractSolver{&lt;:Integer,V}, m::Int, dim::I,
    data::SparseMatrixCOO{I,I,V},
    obj::Union{Nothing,Tuple{Tuple{FastVec{I},FastVec{I}},FastVec{V}}}) where {I,V}</code></pre><p>This form of the function is called from <a href="backend.html#PolynomialOptimization.Solver.primal_moment_setup!"><code>primal_moment_setup!</code></a> when the <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a> is a <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeCOOVectorized"><code>PSDIndextypeCOOVectorized</code></a> and the <a href="backend.html#PolynomialOptimization.Solver.objective_indextype"><code>objective_indextype</code></a> is a <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeMatrixCartesian"><code>PSDIndextypeMatrixCartesian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L143-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_psd!-Union{Tuple{V}, Tuple{I}, Tuple{PolynomialOptimization.Solver.AbstractSolver{&lt;:Integer, V}, Int64, I, Tuple{PolynomialOptimization.FastVector.FastVec{I}, Tuple{PolynomialOptimization.FastVector.FastVec{I}, PolynomialOptimization.FastVector.FastVec{I}}, PolynomialOptimization.FastVector.FastVec{V}}, Union{Nothing, Tuple{PolynomialOptimization.FastVector.FastVec{I}, PolynomialOptimization.FastVector.FastVec{V}}}}} where {I, V}" href="#PolynomialOptimization.Solver.add_var_psd!-Union{Tuple{V}, Tuple{I}, Tuple{PolynomialOptimization.Solver.AbstractSolver{&lt;:Integer, V}, Int64, I, Tuple{PolynomialOptimization.FastVector.FastVec{I}, Tuple{PolynomialOptimization.FastVector.FastVec{I}, PolynomialOptimization.FastVector.FastVec{I}}, PolynomialOptimization.FastVector.FastVec{V}}, Union{Nothing, Tuple{PolynomialOptimization.FastVector.FastVec{I}, PolynomialOptimization.FastVector.FastVec{V}}}}} where {I, V}"><code>PolynomialOptimization.Solver.add_var_psd!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_psd!(state::AbstractSolver{&lt;:Integer,V}, m::Int, dim::I,
    data::Tuple{FastVec{I},Tuple{FastVec{I},FastVec{I}},FastVec{V}},
    obj::Union{Nothing,Tuple{FastVec{I},FastVec{V}}}) where {I,V}</code></pre><p>This form of the function is called from <a href="backend.html#PolynomialOptimization.Solver.primal_moment_setup!"><code>primal_moment_setup!</code></a> when the <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a> is a <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeMatrixCartesian"><code>PSDIndextypeMatrixCartesian</code></a> and the <a href="backend.html#PolynomialOptimization.Solver.objective_indextype"><code>objective_indextype</code></a> is a <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeCOOVectorized"><code>PSDIndextypeCOOVectorized</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L154-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.add_var_psd!-Union{Tuple{V}, Tuple{I}, Tuple{PolynomialOptimization.Solver.AbstractSolver{&lt;:Integer, V}, Int64, I, Tuple{PolynomialOptimization.FastVector.FastVec{I}, Tuple{PolynomialOptimization.FastVector.FastVec{I}, PolynomialOptimization.FastVector.FastVec{I}}, PolynomialOptimization.FastVector.FastVec{V}}, Union{Nothing, Tuple{Tuple{PolynomialOptimization.FastVector.FastVec{I}, PolynomialOptimization.FastVector.FastVec{I}}, PolynomialOptimization.FastVector.FastVec{V}}}}} where {I, V}" href="#PolynomialOptimization.Solver.add_var_psd!-Union{Tuple{V}, Tuple{I}, Tuple{PolynomialOptimization.Solver.AbstractSolver{&lt;:Integer, V}, Int64, I, Tuple{PolynomialOptimization.FastVector.FastVec{I}, Tuple{PolynomialOptimization.FastVector.FastVec{I}, PolynomialOptimization.FastVector.FastVec{I}}, PolynomialOptimization.FastVector.FastVec{V}}, Union{Nothing, Tuple{Tuple{PolynomialOptimization.FastVector.FastVec{I}, PolynomialOptimization.FastVector.FastVec{I}}, PolynomialOptimization.FastVector.FastVec{V}}}}} where {I, V}"><code>PolynomialOptimization.Solver.add_var_psd!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_var_psd!(state::AbstractSolver{&lt;:Integer,V}, m::Int, dim::I,
    data::Tuple{FastVec{I},Tuple{FastVec{I},FastVec{I}},FastVec{V}},
    obj::Union{Nothing,Tuple{Tuple{FastVec{I},FastVec{I}},FastVec{V}}}) where {I,V}</code></pre><p>This form of the function is called from <a href="backend.html#PolynomialOptimization.Solver.primal_moment_setup!"><code>primal_moment_setup!</code></a> when both the <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a> and the <a href="backend.html#PolynomialOptimization.Solver.objective_indextype"><code>objective_indextype</code></a> are of type <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeMatrixCartesian"><code>PSDIndextypeMatrixCartesian</code></a>. Note that the triangles are allowed to be different.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L165-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.fix_constraints!-Union{Tuple{V}, Tuple{PolynomialOptimization.Solver.AbstractSolver{&lt;:Integer, V}, Int64, PolynomialOptimization.Solver.Indvals{&lt;:Integer, V}}} where V" href="#PolynomialOptimization.Solver.fix_constraints!-Union{Tuple{V}, Tuple{PolynomialOptimization.Solver.AbstractSolver{&lt;:Integer, V}, Int64, PolynomialOptimization.Solver.Indvals{&lt;:Integer, V}}} where V"><code>PolynomialOptimization.Solver.fix_constraints!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fix_constraints(state::AbstractSolver{&lt;:Integer,V}, m::Int,
    indvals::Indvals{I,V}) where {I,V}</code></pre><p>Ensures that all constraints in the optimization problem are fixed to the values according to <code>indvals</code>. This form of the function is called from <a href="backend.html#PolynomialOptimization.Solver.primal_moment_setup!"><code>primal_moment_setup!</code></a>. <code>m</code> is the number of constraints in the solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/SOSInterface.jl#L378-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.objective_indextype" href="#PolynomialOptimization.Solver.objective_indextype"><code>PolynomialOptimization.Solver.objective_indextype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">objective_indextype(state)</code></pre><p>For a given solver to be called using <a href="backend.html#PolynomialOptimization.Solver.primal_moment_setup!"><code>primal_moment_setup!</code></a>, define the index type of the objective, which by default is the same as the global one, but can be customized.</p><p>See also <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/DataTypes.jl#L282-L289">source</a></section></article><p>Note that these methods work with the COO representation, which can be quickly converted to either CSR or CSC using <a href="backend.html#PolynomialOptimization.Solver.coo_to_csr!"><code>coo_to_csr!</code></a> and <a href="backend.html#PolynomialOptimization.Solver.coo_to_csc!-Union{Tuple{offset}, Tuple{V}, Tuple{I}, Tuple{Integer, PolynomialOptimization.Solver.SparseMatrixCOO{I, I, V, offset}}} where {I, V, offset}"><code>coo_to_csc!</code></a>, which respects the offset desired by the solver. Only this interface allows to set <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a> to a <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeCOOVectorized"><code>PSDIndextypeCOOVectorized</code></a>; but <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeVector"><code>PSDIndextypeVector</code></a> is now forbidden.</p><h4 id="Helper-functions"><a class="docs-heading-anchor" href="#Helper-functions">Helper functions</a><a id="Helper-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-functions" title="Permalink"></a></h4><p>The solver module exports a number of helper functions which may be of use in implementations:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.@solver_alias" href="#PolynomialOptimization.Solver.@solver_alias"><code>PolynomialOptimization.Solver.@solver_alias</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@solver_alias(alias, original)</code></pre><p>Defines the solver identifier <code>alias</code> to map to the same optimization routine as <code>original</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Solver.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.monomial_count" href="#PolynomialOptimization.Solver.monomial_count"><code>PolynomialOptimization.Solver.monomial_count</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">monomial_count(n, d)</code></pre><p>Short helper function that allows to determine the number of monomials in <code>n</code> variables up to degree <code>d</code>, <span>$\binom{n + d}{n}$</span>. Uses the underlying cache machinery provided by <a href="intpolynomials.html#PolynomialOptimization.IntPolynomials.MultivariateExponents.ExponentsDegree"><code>ExponentsDegree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Helpers.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.trisize" href="#PolynomialOptimization.Solver.trisize"><code>PolynomialOptimization.Solver.trisize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trisize(n)</code></pre><p>Returns the number of items in the triangle of a matrix of side dimension <code>n</code>, <span>$\frac{n(n +1)}{2}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Helpers.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.count_uniques" href="#PolynomialOptimization.Solver.count_uniques"><code>PolynomialOptimization.Solver.count_uniques</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">count_uniques(vec::AbstractVector[, callback])
count_uniques(vec₁::AbstractVector, vec₂::AbstractVector[, callback])</code></pre><p>Return the number of unique elements in the vector(s), which must be sorted but may possibly contain duplicates. The callback is invoked once for every unique entry. Its first parameter is the index of the element in the unique total vector, its second (and third) is the last index/indices correponding to the element in the input vector(s). In the second form which allows to check for two vectors jointly, one of the callback parameters can be <code>missing</code> if the element is present only in one of the two vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/Helpers.jl#L105-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.coo_to_csc!-Union{Tuple{offset}, Tuple{V}, Tuple{I}, Tuple{Integer, PolynomialOptimization.Solver.SparseMatrixCOO{I, I, V, offset}}} where {I, V, offset}" href="#PolynomialOptimization.Solver.coo_to_csc!-Union{Tuple{offset}, Tuple{V}, Tuple{I}, Tuple{Integer, PolynomialOptimization.Solver.SparseMatrixCOO{I, I, V, offset}}} where {I, V, offset}"><code>PolynomialOptimization.Solver.coo_to_csc!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coo_to_csc!(nCols, s::SparseMatrixCOO)</code></pre><p>Converts a COO matrix into a CSC matrix, where the three vectors (colptr, rowvals, nzvals) are returned. The offset of <code>s</code> is respected. Note that some of the vectors in <code>s</code> are modified by this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/PrimalMomentHelpers.jl#L640-L645">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Solver.coo_to_csr!" href="#PolynomialOptimization.Solver.coo_to_csr!"><code>PolynomialOptimization.Solver.coo_to_csr!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coo_to_csr!(nRows, s::SparseMatrixCOO)</code></pre><p>Converts a COO matrix into a CSR matrix, where the three vectors (rowptr, colvals, nzvals) are returned. The offset of <code>s</code> is respected. Note that some of the vectors in <code>s</code> are modified by this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/optimization/solver/PrimalMomentHelpers.jl#L678-L683">source</a></section></article><p>Additionally, <code>Solver</code> reexports a number of useful types and functions for developing the interface (see <code>src/optimization/solver/Solver.jl</code>); therefore, usually only the <code>Solver</code> submodule itself has to be used and not <code>PolynomialOptimization</code> itself. However, note that it is highly recommended to say <code>using PolynomialOptimization: @assert, @inbounds</code> in the solver implementation; this will replace the Base implementations of the macros by ones that, depending on a debugging constant, enable or disable the desired functionality.</p><h2 id="[Newton.halfpolytope](@ref)"><a class="docs-heading-anchor" href="#[Newton.halfpolytope](@ref)"><a href="reference.html#PolynomialOptimization.Newton.halfpolytope"><code>Newton.halfpolytope</code></a></a><a id="[Newton.halfpolytope](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[Newton.halfpolytope](@ref)" title="Permalink"></a></h2><p>Finding the Newton halfpolytope requires a linear solver that supports problem modification for quick reoptimization.  All the functions here are defined in the submodule <code>PolynomialOptimization.Newton</code> and they are not exported.</p><h3 id="solvers_newton"><a class="docs-heading-anchor" href="#solvers_newton">List of supported solvers</a><a id="solvers_newton-1"></a><a class="docs-heading-anchor-permalink" href="#solvers_newton" title="Permalink"></a></h3><p>The following list contains all the solvers and the required packages that provide access to the solver. The name of the solver is identical with the solver method (as a Symbol).</p><table><tr><th style="text-align: right">Solver</th><th style="text-align: center">Package</th><th style="text-align: center">License</th><th style="text-align: center">Speed</th><th style="text-align: center">Accuracy</th><th style="text-align: center">Memory</th></tr><tr><td style="text-align: right">COPT</td><td style="text-align: center"><a href="https://github.com/COPT-Public/COPT.jl/tree/main">COPT.jl</a></td><td style="text-align: center">commercial</td><td style="text-align: center">👍👍👍</td><td style="text-align: center">👍👍👍</td><td style="text-align: center">👍👍👍</td></tr><tr><td style="text-align: right">Mosek</td><td style="text-align: center"><a href="https://github.com/MOSEK/Mosek.jl">Mosek.jl</a></td><td style="text-align: center">commercial</td><td style="text-align: center">👍👍👍</td><td style="text-align: center">👍👍👍</td><td style="text-align: center">👍👍👍</td></tr></table><h3 id="Solver-interface-2"><a class="docs-heading-anchor" href="#Solver-interface-2">Solver interface</a><a class="docs-heading-anchor-permalink" href="#Solver-interface-2" title="Permalink"></a></h3><p>The following functions need to be implemented so that a solver is available via <a href="reference.html#PolynomialOptimization.Newton.halfpolytope"><code>Newton.halfpolytope</code></a>. The preprocessing functions can be omitted if no preprocessing capabilities should be provided.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Newton.preproc" href="#PolynomialOptimization.Newton.preproc"><code>PolynomialOptimization.Newton.preproc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">preproc(V, mons::IntMonomialVector, vertexindices, verbose::Bool, singlethread::Bool;
    parameters...) -&gt; AbstractVector{Bool}</code></pre><p>Checks for convex dependencies of exponents from the list of monomials. <code>vertexindices</code> might either be a <code>Vector{Int}</code> that indexes <code>mons</code> or is it <code>Val(:all)</code>. In the former case, the convex polytope is spanned by the exponents of all monomials in <code>mons[vertexindices]</code> (and it can be assumed that those are independent, and that <code>vertexindices</code> is fairly short compared to <code>mons</code>); in the latter case, the convex polytope is potentially spanned by the exponents of all monomials in <code>mons</code>. The implementation has to return an <code>AbstractVector{Bool}</code> that for every monomial in <code>mons</code> indicates whether the convex hull spanned by the elements just described (excluding the monomial in question) already contains the monomial. An entry must be <code>false</code> if and only if this is possible, i.e., it is redundant. <code>singlethread</code> will be <code>true</code> if this function will be called in parallel by multiple threads, so that the linear solver itself should be single-threaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/newton/Interface.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Newton.prepare" href="#PolynomialOptimization.Newton.prepare"><code>PolynomialOptimization.Newton.prepare</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepare(V, vertices::IntMonomialVector, num::Int, verbose::Bool; parameters...) -&gt;
    (nthreads::Int, userdata, userdata_clone)</code></pre><p>This function is responsible for creating an optimization task that can be used to check membership in the Newton halfpolytope. The vertices of the polytope are given by the exponents of <code>mons</code>. The total number of monomials that have to be checked is given by <code>num</code>. The function must return the number of threads that will be used to carry out the optimization (which is not the number of threads that the optimizer uses internally, but determines how <code>PolynomialOptimization</code> will distribute the jobs), an internal optimization task that is passed on to <a href="backend.html#PolynomialOptimization.Newton.work"><code>work</code></a>, and a copy of this task for use in a second thread if the number of threads is greater than one, else <code>nothing</code>. More copies will be created as required by <a href="backend.html#PolynomialOptimization.Newton.clonetask"><code>clonetask</code></a>; however, assuming that setting up the task will potentially require more resources than cloning a task allows the function to estimate the required memory (and therefore a sensible number of threads) better by already performing one clone.</p><p>See also <a href="auxreference.html#PolynomialOptimization.@allocdiff"><code>@allocdiff</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/newton/Interface.jl#L18-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Newton.alloc_global" href="#PolynomialOptimization.Newton.alloc_global"><code>PolynomialOptimization.Newton.alloc_global</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alloc_global(V, nv)</code></pre><p>This function is called once in the main thread before <a href="backend.html#PolynomialOptimization.Newton.work"><code>work</code></a> is executed (which, due to multithreading, might occur more than once). It can create some shared data that is used in a read-only manner by all workers at the same time. The default implementation of this function does nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/newton/Interface.jl#L36-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Newton.alloc_local" href="#PolynomialOptimization.Newton.alloc_local"><code>PolynomialOptimization.Newton.alloc_local</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alloc_local(V, nv)</code></pre><p>This function is called once in every computation thread before <a href="backend.html#PolynomialOptimization.Newton.work"><code>work</code></a> is executed (which, due to task splitting, might occur more than once). It can create some shared data that is available for reading and writing by every worker. The default implementation of this function does nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/newton/Interface.jl#L45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Newton.clonetask" href="#PolynomialOptimization.Newton.clonetask"><code>PolynomialOptimization.Newton.clonetask</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clonetask(t)</code></pre><p>This function must create a copy of the optimization task <code>t</code> that can run in parallel to <code>t</code> in a different thread.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/newton/Interface.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.Newton.work" href="#PolynomialOptimization.Newton.work"><code>PolynomialOptimization.Newton.work</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">work(V, task, data_global, data_local, expiter::IntMonomialVectorIterator{true},
    Δprogress::Ref{Int}, Δacceptance::Ref{Int}, add_callback::Function,
    iteration_callback::Union{Nothing,Function})</code></pre><p>Iterates through <code>expiter</code> (which gives a tuple consisting of the index and the exponents) and for every exponent checks whether this it can be obtained by a convex combination of the coefficients as they are set up in <code>task</code>. If yes, <code>add_callback</code> must be called with the exponent index as a parameter, and <code>Δacceptance</code> should be incremented. In any case, <code>Δprogress</code> should be incremented. Additionally, after every check, <code>iteration_callback</code> should be called with no parameters, if it is a function. The <code>data</code> parameters contain the custom data that was previously generated using <a href="backend.html#PolynomialOptimization.Newton.alloc_global"><code>alloc_global</code></a> and <a href="backend.html#PolynomialOptimization.Newton.alloc_local"><code>alloc_local</code></a>. Only <code>data_local</code> may be mutated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/newton/Interface.jl#L61-L73">source</a></section></article><p>Once a solver has been implemented, it should add its solver symbol to the vector <code>Newton.newton_methods</code>, which enables this solver to be chosen automatically.</p><h2 id="Automatic-tightening"><a class="docs-heading-anchor" href="#Automatic-tightening">Automatic tightening</a><a id="Automatic-tightening-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-tightening" title="Permalink"></a></h2><p>Automatic tightening of a polynomial optimization problem requires a linear solver that finds a solution to a system of linear equations that minimizes the ℓ₁ norm (better yet, the ℓ₀-norm, if you can implement this). The solver is only called if the number of rows is smaller than the number of columns; else, the solution is calculated using SPQR&#39;s direct solver.</p><h3 id="solvers_tighten"><a class="docs-heading-anchor" href="#solvers_tighten">List of supported solvers</a><a id="solvers_tighten-1"></a><a class="docs-heading-anchor-permalink" href="#solvers_tighten" title="Permalink"></a></h3><p>The following list contains all the solvers and the required packages that provide access to the solver. The name of the solver is identical with the solver method (as a Symbol).</p><table><tr><th style="text-align: right">Solver</th><th style="text-align: center">Package</th><th style="text-align: center">License</th><th style="text-align: center">Speed</th><th style="text-align: center">Accuracy</th><th style="text-align: center">Memory</th></tr><tr><td style="text-align: right">COPT</td><td style="text-align: center"><a href="https://github.com/COPT-Public/COPT.jl/tree/main">COPT.jl</a></td><td style="text-align: center">commercial</td><td style="text-align: center">👍👍👍</td><td style="text-align: center">👍👍👍</td><td style="text-align: center">👍👍👍</td></tr><tr><td style="text-align: right">Mosek</td><td style="text-align: center"><a href="https://github.com/MOSEK/Mosek.jl">Mosek.jl</a></td><td style="text-align: center">commercial</td><td style="text-align: center">👍👍👍</td><td style="text-align: center">👍👍👍</td><td style="text-align: center">👍👍👍</td></tr></table><h3 id="Solver-interface-3"><a class="docs-heading-anchor" href="#Solver-interface-3">Solver interface</a><a class="docs-heading-anchor-permalink" href="#Solver-interface-3" title="Permalink"></a></h3><p>The following function needs to be implemented so that a solver is available via automatic tightening.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PolynomialOptimization.tighten_minimize_l1" href="#PolynomialOptimization.tighten_minimize_l1"><code>PolynomialOptimization.tighten_minimize_l1</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tighten_minimize_l1(V, spmat::SparseMatrixCSC, rhs::Vector)</code></pre><p>Computes a solution to the underdetermined linear system <code>spmat * x = rhs</code> with minimal ℓ₁-norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/projekter/PolynomialOptimization.jl/blob/7ecbc9c0d4619e99e73600bd4f011729692e3a78/src/Tightening.jl#L9-L13">source</a></section></article><p>Once a solver has been implemented, it should add its solver symbol to the vector <code>PolynomialOptimization.tightening_methods</code>, which enables this solver to be chosen automatically.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>If the return type is a vector, <a href="backend.html#PolynomialOptimization.Solver.psd_indextype"><code>psd_indextype</code></a> should be defined on <code>state</code>, and it must return a   <a href="backend.html#PolynomialOptimization.Solver.PSDIndextypeVector"><code>PSDIndextypeVector</code></a>. The <code>scaling</code> property of the index type will automatically be inverted, so that what was   <span>$\sqrt2$</span> before now becomes <span>$\frac{1}{\sqrt2}$</span>.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Complex values can be treated either by returning a vector of <code>Complex</code> element type, or by returning a real-valued   vector where the diagonals (PSD/DD/SDD)/first elements (<span>$\ell$</span>-norm) have a single entry and off-diagonals two.</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>This identifier will be a tuple, where the first element is a symbol - either <code>:objective</code>, <code>:nonneg</code>, or <code>:psd</code> - to   indicate the general reason why the variable is there. The second element is an <code>Int</code> denoting the index of the   constraint (and will be undefined for the objective, but still present to avoid extra compilation). The last element   is an <code>Int</code> denoting the index of the grouping within the constraint/objective.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="includedsolvers.html">« Supported solvers</a><a class="docs-footer-nextpage" href="auxreference.html">Reference of auxilliaries »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Sunday 30 March 2025 14:49">Sunday 30 March 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
